<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Html&amp;&amp;CSS</title>
    <link href="/2025/08/12/Full-Stack/Html-CSS/"/>
    <url>/2025/08/12/Full-Stack/Html-CSS/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"todolist"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span><br>            Richard的todolist<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"todo-form"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"todo-input"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入待办事项"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"todo-button"</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item completed"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"name"</span>&gt;</span>吃饭<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"del"</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"name"</span>&gt;</span>睡觉<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"del"</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"name"</span>&gt;</span>学习<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"del"</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.completed</span>{</span><br><span class="language-css">            <span class="hljs-attribute">text-decoration</span>: line-through;</span><br><span class="language-css">            <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.4</span>;</span><br><span class="language-css">        }</span><br><span class="language-css">        <span class="hljs-selector-class">.del</span>{</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        }</span><br><span class="language-css">        <span class="hljs-selector-class">.item</span>{</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">            <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 垂直居中对齐 */</span></span><br><span class="language-css">            <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">8px</span> auto;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">20px</span> <span class="hljs-number">0</span>; </span><br><span class="language-css">            <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>); <span class="hljs-comment">/* 修复阴影语法 */</span></span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f9f9f9</span>;</span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-class">.todo-form</span>{ </span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span> auto; <span class="hljs-comment">/* 居中表单 */</span></span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>; <span class="hljs-comment">/* 固定表单高度 */</span></span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-class">.todo-input</span>{ </span><br><span class="language-css">            <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">15px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#dfe1e5</span>; </span><br><span class="language-css">            <span class="hljs-attribute">outline</span>: none;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">100px</span>); <span class="hljs-comment">/* 自动计算宽度 */</span></span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 与按钮同高 */</span></span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 修复语法错误 */</span></span><br><span class="language-css">            <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 确保padding不增加总宽度 */</span></span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-class">.todo-button</span>{</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 与输入框同高 */</span></span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">20px</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(</span><br><span class="language-css">                to right,</span><br><span class="language-css">                <span class="hljs-built_in">rgb</span>(<span class="hljs-number">113</span>,<span class="hljs-number">65</span>,<span class="hljs-number">168</span>),</span><br><span class="language-css">                <span class="hljs-built_in">rgba</span>(<span class="hljs-number">44</span>, <span class="hljs-number">144</span>, <span class="hljs-number">251</span>,<span class="hljs-number">1</span>)</span><br><span class="language-css">            );</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 垂直居中文字 */</span></span><br><span class="language-css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>; <span class="hljs-comment">/* 与高度一致实现垂直居中 */</span></span><br><span class="language-css">            <span class="hljs-attribute">cursor</span>: pointer;</span><br><span class="language-css">            <span class="hljs-attribute">user-select</span>: none;</span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-tag">body</span>{</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(</span><br><span class="language-css">                to right,</span><br><span class="language-css">                <span class="hljs-built_in">rgb</span>(<span class="hljs-number">113</span>,<span class="hljs-number">65</span>,<span class="hljs-number">168</span>),</span><br><span class="language-css">                <span class="hljs-built_in">rgba</span>(<span class="hljs-number">44</span>, <span class="hljs-number">144</span>, <span class="hljs-number">251</span>,<span class="hljs-number">1</span>)</span><br><span class="language-css">            );</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-class">.todolist</span>{</span><br><span class="language-css">            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>; <span class="hljs-comment">/* 限制最大宽度 */</span></span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: white;</span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">40px</span> auto; <span class="hljs-comment">/* 水平居中 */</span></span><br><span class="language-css">            <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-number">15px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.1</span>);</span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-class">.title</span>{</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">113</span>,<span class="hljs-number">65</span>,<span class="hljs-number">168</span>);</span><br><span class="language-css">            <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-class">.del</span> {</span><br><span class="language-css">            <span class="hljs-attribute">margin-left</span>: auto;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff4444</span>;</span><br><span class="language-css">            <span class="hljs-attribute">cursor</span>: pointer;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">12px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fef0f0</span>;</span><br><span class="language-css">        }</span><br><span class="language-css">        </span><br><span class="language-css">        <span class="hljs-selector-class">.name</span> {</span><br><span class="language-css">            <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">        }</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> <br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Full Stack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Powerful Editor:Vim</title>
    <link href="/2025/07/28/Tutorial/Powerful-Editor-Vim/"/>
    <url>/2025/07/28/Tutorial/Powerful-Editor-Vim/</url>
    
    <content type="html"><![CDATA[<p>A brief tutorial of Editor Vim,including the Unique Philosophy and Basic Commands!</p><span id="more"></span><div class="note note-primary">            <p>“Writing English words and writing code are very different activities. When programming, you spend more time switching files, reading, navigating, and editing code compared to writing a long stream.”—— &lt; The Missing Semester of Your CS Education &gt;</p>          </div><p><code>Vim</code> 是一个<strong>模态编辑器</strong>（modal editor），它的设计哲学是：编辑操作应当通过<strong>键盘组合</strong>完成，而非依赖鼠标或菜单。</p><div class="note note-primary">            <p>“Vim avoids the use of the mouse, because it’s too slow; Vim even avoids using the arrow keys because it requires too much movement.”—— &lt; The Missing Semester of Your CS Education &gt;</p>          </div><p><code>Vim</code>认为使用鼠标浪费时间，会降低效率，因为手从鼠标移动到键盘需要一定时间，对程序员来说反复来回的切换是很<code>annoying</code>的。因此，所有的<code>vim</code>功能都可以通过键盘操作，或许一开始你并不习惯，但等你使用久了，便能发现它得到程序员青睐的原因！😊</p><p>课程相关视频与讲义：<a href="https://missing.csail.mit.edu/2020/editors/">Editors (Vim)</a></p><h2 id="核心特性">核心特性</h2><ul><li><code>普通模式</code>：用于导航和操作文本（默认模式）</li><li><code>插入模式</code>：像常规编辑器一样输入文本（按 <code>i</code> 进入）</li><li><code>可视模式</code>：选择文本块（按 <code>v</code> 进入）</li><li><code>命令行模式</code>：执行保存/退出等命令（按 <code>:</code> 进入）</li></ul><h2 id="基础操作">基础操作</h2><p>使用 <code>Vim</code> 时会经常使用<code>&lt;ESC&gt;</code>键，而它不在主键盘区，显然不那么方便，于是很多程序员考虑将 <code>Caps Lock</code> 重新映射到 <code>Escape</code>或使用简单的键序列创建替代映射！</p><h3 id="模式切换">模式切换</h3><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td><code>vim</code></td><td>进入vim编辑器</td></tr><tr><td><code>vim 文件名</code></td><td>打开特定文件（不存在时会新建）</td></tr><tr><td><code>i</code>(<code>insert</code>)</td><td>进入插入模式</td></tr><tr><td><code>Esc</code></td><td>返回普通模式</td></tr><tr><td><code>:</code></td><td>进入命令行模式</td></tr></tbody></table><h3 id="光标移动">光标移动</h3><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td><code>h</code> <code>j</code> <code>k</code> <code>l</code></td><td>左/下/上/右移动</td></tr><tr><td><code>0</code></td><td>移动到行首</td></tr><tr><td><code>$</code></td><td>移动到行尾</td></tr><tr><td><code>^</code></td><td>移动到行首非空字符</td></tr><tr><td><code>G</code></td><td>移动到文件底部</td></tr><tr><td><code>gg</code></td><td>移动到文件顶部</td></tr><tr><td><code>H</code></td><td>移动到窗口顶部</td></tr><tr><td><code>L</code></td><td>移动到窗口底部</td></tr><tr><td><code>Ctrl+u</code></td><td>上翻半页</td></tr><tr><td><code>Ctrl+d</code></td><td>下翻半页</td></tr><tr><td><code>Ctrl+b</code></td><td>上翻整页</td></tr><tr><td><code>Ctrl+f</code></td><td>下翻整页</td></tr></tbody></table><h2 id="编辑功能">编辑功能</h2><h3 id="文本操作">文本操作</h3><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td><code>o</code></td><td>下方新建行并插入</td></tr><tr><td><code>O</code></td><td>上方新建行并插入</td></tr><tr><td><code>u</code></td><td>撤销</td></tr><tr><td><code>Ctrl+r</code></td><td>重做</td></tr><tr><td><code>x</code></td><td>删除字符</td></tr><tr><td><code>dw</code></td><td>删除单词</td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>cc</code></td><td>删除并进入插入模式</td></tr></tbody></table><h3 id="复制粘贴">复制粘贴</h3><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td><code>y</code> (<code>yank</code>)</td><td>复制</td></tr><tr><td><code>yy</code></td><td>复制当前行</td></tr><tr><td><code>yw</code></td><td>复制单词</td></tr><tr><td><code>p</code>(<code>paste</code>)</td><td>粘贴</td></tr></tbody></table><h3 id="可视化模式">可视化模式</h3><table><thead><tr><th>操作</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><code>v</code></td><td>字符可视化</td><td>按字符选择</td></tr><tr><td><code>V</code></td><td>行可视化</td><td>按行选择</td></tr><tr><td><code>Ctrl+v</code></td><td>块可视化</td><td>矩形选择</td></tr></tbody></table><h2 id="高级功能">高级功能</h2><h3 id="搜索与替换">搜索与替换</h3><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td><code>f+字符</code></td><td>向前查找字符</td></tr><tr><td><code>F+字符</code></td><td>向后查找字符</td></tr><tr><td><code>~</code></td><td>大小写转换</td></tr></tbody></table><h3 id="批量操作">批量操作</h3><p><code>数字+指令</code>可以进行批量化操作</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">4j <span class="hljs-comment">#向下移动4行 </span><br>3ee <span class="hljs-comment">#选择3个单词 </span><br>7dw <span class="hljs-comment">#删除7个单词</span><br></code></pre></td></tr></tbody></table></figure><h2 id="文件操作">文件操作</h2><h3 id="保存与退出">保存与退出</h3><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td><code>:w</code>(<code>write</code>)</td><td>保存文件</td></tr><tr><td><code>:q</code>(<code>quit</code>)</td><td>退出</td></tr><tr><td><code>:qa</code>(<code>all</code>)</td><td>退出所有窗口</td></tr><tr><td><code>:wq</code></td><td>保存并退出</td></tr></tbody></table><h3 id="实战演示">实战演示</h3><p>学习了上面那么多的指令不妨自己创建一个<code>python</code>文件，结合之前学习的<code>shell</code>命令，在实践中感受<code>Vim</code>的魅力吧！😄</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys <span class="hljs-comment">#导入sys来接受shell中的参数</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fizz_buzz</span>(<span class="hljs-params">limit</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, limit + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(i)<br>        <span class="hljs-keyword">elif</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">'fizz'</span>)<br>        <span class="hljs-keyword">elif</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">'buzz'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">'fizzbuzz'</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    fizz_buzz(<span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>]))<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure>   <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">   $ python3 fizzbuzz.py 30<br>1<br>2<br>fizz<br>4<br>buzz<br>fizz<br>7<br>8<br>fizz<br>buzz<br>11<br>fizz<br>13<br>14<br>fizzbuzz<br>16<br>17<br>fizz<br>19<br>buzz<br>fizz<br>22<br>23<br>fizz<br>buzz<br>26<br>fizz<br>28<br>29<br>fizzbuzz<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell Magic: Notes from MIT</title>
    <link href="/2025/07/27/Tutorial/Shell-Magic-Notes-from-The-Missing-Semester/"/>
    <url>/2025/07/27/Tutorial/Shell-Magic-Notes-from-The-Missing-Semester/</url>
    
    <content type="html"><![CDATA[<p>This document summarizes my key takeaways from the Shell module of MIT’s The Missing Semester course, focusing on:Interaction and Automation Power!</p><span id="more"></span><blockquote><p>对计算机的学生而言，许多开发工具是未来老师或企业默认你已经“精通”的，然而未经学校系统培训的我们或许会对此感到迷茫，正如 MIT 课程 <strong><a href="https://missing.csail.mit.edu/">The Missing Semester of Your CS Education</a></strong> 所强调的： <strong>“掌握基础工具是程序员的核心竞争力”</strong>。这个课程会帮助你入门、了解一些计算机常用的开发工具，也算是程序员的自我修养吧！<strong>Let’s Go！</strong>😄</p></blockquote><p>相关课程在b站也有双语翻译（大部分应该都能听懂，就是有个好像是西班牙的老师带点口音听起来有点不适应😢）<a href="https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a">[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell</a></p><h2 id="Shell">Shell</h2><p>  当熟悉的可视化界面无法实现你想要的功能时，<code>Shell</code>将成为你与计算机交互的强大工具。相比图形界面有限的按钮和滑块，命令行提供了更灵活、更强大的控制方式，允许你通过文本命令和脚本实现自动化操作。本文基于<code>VMware</code>虚拟机中的<code>Ubuntu 22.04</code>发行版演示基础<code>Shell</code>操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">date</span><br>Sat Jul 26 03:27:54 PM CST 2025<br></code></pre></td></tr></tbody></table></figure><p>第一行通常是用户名、机器名称和当前所在路径</p><ul><li><code>Windows</code>中路径通常使用<strong>反斜杠</strong><code>\</code>分隔，每个驱动器都有一个单独的路径结构。</li><li><code>Linux</code> / <code>macOS</code> 中这些路径使用<strong>正斜杠</strong><code>/</code>分隔，他们挂载在同一个命名空间下。</li></ul><p>开头的斜杠表示从文件系统的顶部开始。</p><ul><li>相对路径：相对于当前位置的路径</li><li>绝对路径：完整路径，从顶部开始</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello World"</span><br>Hello World<br></code></pre></td></tr></tbody></table></figure><p><code>echo</code>可以将后面的参数打印在屏幕上</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">which</span> <span class="hljs-built_in">echo</span><br>/usr/bin/echo<br></code></pre></td></tr></tbody></table></figure><p><code>which</code>可以用于寻找后面参数文件的绝对位置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">pwd</span><br>/home/richard<br></code></pre></td></tr></tbody></table></figure><p><code>pwd</code>（<code>Print Working Directory</code>）打印当前所在路径</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">cd</span> /home<br>richard@richard-VMware-Virtual-Platform:/home$ <br></code></pre></td></tr></tbody></table></figure><p><code>cd</code>（<code>Change Directory</code>）表示更改当前目录</p><p>这是更方便切换目录的方式：</p><ul><li><code>.</code>表示<strong>当前</strong>目录</li><li><code>..</code>表示<strong>父</strong>目录</li></ul><p><strong>注意</strong>：使用相对路径能提高命令在不同电脑上的<strong>兼容性</strong>！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:/$ <span class="hljs-built_in">ls</span><br>bin                home               mnt   sbin.usr-is-merged  usr<br>bin.usr-is-merged  lib                opt   snap                var<br>boot               lib64              proc  srv<br>cdrom              lib.usr-is-merged  root  swap.img<br>dev                lost+found         run   sys<br>etc                media              sbin  tmp<br></code></pre></td></tr></tbody></table></figure><p><code>ls</code>会列出当前目中的文件，这能够快速浏览文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:/home$ <span class="hljs-built_in">cd</span> ~<br>richard@richard-VMware-Virtual-Platform:~$<br></code></pre></td></tr></tbody></table></figure><ul><li><code>cd ~</code>能够快速回到用户主目录</li><li><code>cd -</code>切换到上一个工作目录</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">ls</span> --<span class="hljs-built_in">help</span><br>Usage: <span class="hljs-built_in">ls</span> [OPTION]... [FILE]...<br>List information about the FILEs (the current directory by default).<br>Sort entries alphabetically <span class="hljs-keyword">if</span> none of -cftuvSUX nor --<span class="hljs-built_in">sort</span> is specified.<br></code></pre></td></tr></tbody></table></figure><p><code>--help</code>参数显示命令帮助信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">ls</span> -l<br>total 40<br>drwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Desktop<br>drwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Documents<br><br>lrwxrwxrwx   1 root root          7 Apr 22  2024 bin -&gt; usr/bin<br>drwxr-xr-x   2 root root       4096 Feb 26  2024 bin.usr-is-merged<br><span class="hljs-comment"># 仅列举部分进行展示说明</span><br></code></pre></td></tr></tbody></table></figure><p><strong>文件类型</strong>（第<code>1</code>个字符）</p><table><thead><tr><th>字符</th><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>d</code></td><td>目录</td><td>文件夹</td><td><code>drwxr-xr-x</code></td></tr><tr><td><code>-</code></td><td>普通文件</td><td>文本/二进制文件</td><td><code>-rw-r--r--</code></td></tr><tr><td><code>l</code></td><td>符号链接</td><td>软链接文件</td><td><code>lrwxrwxrwx</code></td></tr><tr><td><code>c</code></td><td>字符设备</td><td>终端等串行设备</td><td><code>crw--w----</code></td></tr><tr><td><code>b</code></td><td>块设备</td><td>磁盘等存储设备</td><td><code>brw-rw----</code></td></tr><tr><td><code>s</code></td><td>套接字</td><td>进程通信文件</td><td><code>srwxrwxrwx</code></td></tr><tr><td><code>p</code></td><td>管道</td><td><code>FIFO</code> 管道文件</td><td><code>prw-------</code></td></tr></tbody></table><p>用户权限分为 <strong>3组</strong>（每组<code>3</code>字符），分别对应：</p><table><thead><tr><th>组别</th><th>示例</th></tr></thead><tbody><tr><td>所有者权限</td><td><code>rwx</code></td></tr><tr><td>所属组权限</td><td><code>r-x</code></td></tr><tr><td>其他用户</td><td><code>r-x</code></td></tr></tbody></table><p>权限字符<strong>含义</strong>：</p><table><thead><tr><th>字符</th><th>权限</th><th>对文件的影响</th><th>对目录的影响</th></tr></thead><tbody><tr><td><code>r</code></td><td>读</td><td>查看文件内容</td><td>列出目录内容（<code>ls</code>）</td></tr><tr><td><code>w</code></td><td>写</td><td>修改/删除文件</td><td>创建/删除目录内文件</td></tr><tr><td><code>x</code></td><td>执行</td><td>运行程序/脚本</td><td>进入目录（<code>cd</code>）</td></tr><tr><td><code>-</code></td><td>无</td><td>无权限</td><td>无权限</td></tr></tbody></table><p><strong>注意</strong>：</p><ol><li>即使文件本身有 <code>w</code> 权限，如果所在目录没有<code> w</code>，你只能<strong>清空或删除文件内容</strong>，却仍然<strong>无法删除或重命名</strong>它</li><li>如果我想要访问一个目录，<strong>必须拥有其所有父目录的权限</strong>：<code>/usr/bin/echo</code>我必须拥有<code>/usr</code> <code>/bin</code>目录的权限，否则我将不被允许访问该文件，因为我将无法进入其中的目录</li></ol><p><code>mv</code>能将文件修改位置并重命名<br><code>cp</code>复制文件 需要两个参数 一个是要复制的文件路径 一个目标文件路径<br><code>rm</code>用于删除文件<br><code>rmdir</code>能删除一个目录 但它只能删除空目录 防止不小心删除一大堆文件<br><code>mkdir</code>创建目录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> My Photos<br></code></pre></td></tr></tbody></table></figure><p><code>mkdir</code>创建目录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-string">"My Photos"</span><br></code></pre></td></tr></tbody></table></figure><p>这里如果不加上上引号则会创建两个目录<br><code>man+指令</code> 查找手册<br><code>ctrl+l</code>清空窗口</p><h3 id="输入流和输出流">输入流和输出流</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> hello &gt; hello.txt<br></code></pre></td></tr></tbody></table></figure><p><code>&gt;</code>覆盖输出到文件<br><code>&lt;</code>从文件读取输入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">cat</span> hello.txt<br>hello<br></code></pre></td></tr></tbody></table></figure><p>通过<code>cat</code>指令输出文件内容</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">cat</span> &lt;hello.txt&gt;hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">cat</span> hello2.txt<br>hello<br></code></pre></td></tr></tbody></table></figure><p><code>&lt;</code>将<code>hello.txt</code>作为输入内容并通过<code>&gt;</code>将<code>cat</code>打印的任何内容输出到<code>hello2.txt</code>文件中</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">cat</span> &lt;hello.txt&gt;&gt;hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">cat</span> hello2.txt<br>hello<br>hello<br></code></pre></td></tr></tbody></table></figure><p><code>&gt;&gt;</code>表示追加而不是覆盖(<code>append instead of overwrite</code>)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">ls</span> -l|<span class="hljs-built_in">tail</span> -n1<br>drwxrwxr-x 3 richard richard 4096 Mar  9 12:26 web<br></code></pre></td></tr></tbody></table></figure><p>管道运算符<code>|</code>作用是将<strong>左侧命令的输出</strong>作为<strong>右侧命令的输入</strong>：可以连接多个命令形成<strong>处理流水线</strong></p><p><code>tail</code>将输出最后一行的内容</p><h3 id="用户权限管理">用户权限管理</h3><p><code>root</code>相当于<code>Windows</code>的管理员权限，是一位<strong>超级用户</strong>，可以做任何想做的事情，倘若一直使用<code>root</code>用户操作计算机，如果运行了错误的程序，那会彻底毁坏你的电脑！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:/sys/class/backlight$ <span class="hljs-built_in">sudo</span> su<br>[<span class="hljs-built_in">sudo</span>] password <span class="hljs-keyword">for</span> richard: <br>root@richard-VMware-Virtual-Platform:/sys/class/backlight# <br></code></pre></td></tr></tbody></table></figure><p>通过<code>sudo su</code>来进入<code>root</code>身份，同时提示符由<code>$</code>变为<code>#</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@richard-VMware-Virtual-Platform:/sys/class/backlight# <span class="hljs-built_in">exit</span><br><span class="hljs-built_in">exit</span><br>richard@richard-VMware-Virtual-Platform:/sys/class/backlight$<br></code></pre></td></tr></tbody></table></figure><p><code>exit</code>来退出用户权限</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ xdg-open hello.txt<br></code></pre></td></tr></tbody></table></figure><p>这样就可以直接在<code>terminal</code>打开文件！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ foo=bar<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$foo</span><br>bar<br></code></pre></td></tr></tbody></table></figure><p>在<code>shell</code>中，<code>$</code>符号是一个特殊字符，主要用于变量展开。当你在变量名前面加上$时，<code>shell</code>会将其替换为该变量的值！</p><ul><li><code> foo</code> 会被<code>Shell</code>视为普通字符串</li><li><code>$foo</code> 告诉<code>Shell</code>这是一个需要展开的变量</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ichard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello"</span><br>Hello<br>richard@richard-VMware-Virtual-Platform:~$ foo=World<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello foo"</span><br>Hello foo<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"Hello <span class="hljs-variable">$foo</span>"</span><br>Hello World<br></code></pre></td></tr></tbody></table></figure><p>在<code>shell</code>中我们一定要非常注意<strong>空格</strong><code>space</code>的使用，它是用作不同参数间的分隔符，倘若多打一个可能就会出现报错！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-literal">false</span><br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> $?<br>1<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-literal">true</span><br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> $?<br>0<br></code></pre></td></tr></tbody></table></figure><p><code>$? </code>是一个特殊变量，存储上一个命令的退出状态码</p><ul><li><code>false</code> 是一个 Shell 内置命令，返回非零退出状态（失败）设置退出状态码为 1（表示失败）</li><li><code>true</code> 也是一个 Shell 内置命令，返回零退出状态（成功）退出状态码被设为 0（表示成功）</li></ul><p>  这里看上去有点反常理，我们学的其他编程语言中<code>0</code>是<code>false</code>，非零是<code>true</code>，为什么这里反过来了？<br>  当我们想到<code>c</code>、<code>c++</code>中<code>main</code><strong>函数结束的返回值</strong>或许就不奇怪了！<code>main() </code>函数默认返回<code>0</code> 表示成功，非零表示错误（如 <code>return 1</code>;）。</p><p>再考虑到程序运行只有两种可能：</p><ol><li>完全成功（<strong>唯一状态 0</strong>）</li><li>失败（可能有多种原因，<strong>用不同非零值区分</strong>）：</li></ol><ul><li>0 = 没有错误（成功）</li><li>1 = 通用错误</li><li>2 = 参数错误</li><li>3 = 文件不存在</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-literal">false</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"Oops fail"</span><br>Oops fail<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-literal">true</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">"Will be not be printed"</span><br>richard@richard-VMware-Virtual-Platform:~$<br></code></pre></td></tr></tbody></table></figure><p><code>shell</code>中<code>||</code>同样遵循<strong>短路原则</strong>，<code>&amp;&amp;</code>同理！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"We are now at <span class="hljs-subst">$(pwd)</span>"</span><br>We are now at /home/richard<br></code></pre></td></tr></tbody></table></figure><p><code>shell</code>中使用<code>$(command)</code>进行<strong>命令替换</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">ls</span><br>Desktop    Downloads   hello.txt  Pictures  snap       Videos<br>Documents  hello2.txt  Music      Public    Templates  web<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">ls</span> *.txt<br>hello2.txt  hello.txt<br></code></pre></td></tr></tbody></table></figure><p><code>*</code>是一个<strong>通配符</strong>（<code>globbing</code>）：表示<strong>匹配任意数量的任意字符</strong>（<strong>包括零个字符</strong>）。<code>Shell</code>会在执行<code>ls</code> 前先展开 <code>*.txt</code>，将其替换为所有匹配的文件名，相当于寻找所有后缀为<code>.txt</code>的文件！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">ls</span> hello?.txt<br>hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">ls</span> hello*.txt<br>hello2.txt  hello.txt<br></code></pre></td></tr></tbody></table></figure><p>这里可以看到<code>?</code>也是<strong>通配符</strong>，表示匹配任意一个字符（区别是必须存在，<strong>不能匹配空字符</strong>）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env python3 #自动查找python3</span><br></code></pre></td></tr></tbody></table></figure><p>通过<code>Shell</code>调用<code>Python</code>脚本可以充分发挥两者的优势：<code>Shell</code>的<strong>流程控制能力</strong>结合<code>Python</code>的<strong>丰富库函数</strong>，但我们要在路径中找到并配置好<code>python</code>解释器。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">import sys<br></code></pre></td></tr></tbody></table></figure><p>由于<code>shell</code>默认不会执行<code>python</code>指令，我们需要添加库函数，来让<code>python</code>接受<code>shell</code>传递的参数</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">history</span><br></code></pre></td></tr></tbody></table></figure><p>我们可以使用⬆️来一个个<strong>浏览历史记录命令</strong>，我们也可以使用<code>history</code>直接打印所有历史命令！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">richard@richard-VMware-Virtual-Platform:~$ <span class="hljs-built_in">history</span> | grep git<br></code></pre></td></tr></tbody></table></figure><p>我们通过<code>history +N | grep +指令</code>来查找所有与指令字符串相匹配的<code>N</code>条历史记录命令！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tree<br></code></pre></td></tr></tbody></table></figure><p>能列出<strong>目录结构性</strong>的位置！</p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The CS61A Lab Notebook1</title>
    <link href="/2025/07/25/Python/The-CS61A-Lab-Notebook1/"/>
    <url>/2025/07/25/Python/The-CS61A-Lab-Notebook1/</url>
    
    <content type="html"><![CDATA[<p>This blog will document my notes and insights as I work through this challenging yet rewarding curriculum!</p><span id="more"></span><blockquote><p>笔者在学校仅仅学习了C++，对其他语言知之甚少，然而在实际应用中，Python的应用场景之广泛令人惊叹：无论是数学建模中的数据可视化、数据分析，还是计算机视觉领域的机器学习与深度学习，Python都展现出无可替代的重要性。虽然高中时曾对Python有所涉猎，但不成体系。</p></blockquote><blockquote><p>我深知在计算机领域，自主学习能力至关重要。然而平日既要应对繁重的课业，又要准备各类竞赛，实在分身乏术。值此暑假时间充裕之际，我决定研读计算机领域的标杆课程——CS61A。希望能够有所收获！以下是我的学习笔记，大家共勉！</p></blockquote><h2 id="What’s-the-CS61A">What’s the CS61A?</h2><p>  <code>CS61A</code>是加州大学伯克利分校（<code>UC Berkeley</code>）计算机科学专业的入门课程，全称为"计算机程序的结构与解释"(<code>Structure and Interpretation of Computer Programs</code>)。这门课程<strong>采用<code>Python</code>作为主要教学语言</strong>，同时涵盖<code>Scheme</code>和<code>SQL</code>。课程核心在于<strong>培养计算思维</strong>而非单纯编程技巧，<strong>重点教授抽象思想、函数式编程和元语言抽象</strong>，被誉为"真正教会学生如何思考的计算入门课"！</p><p>这里是<a href="https://cs61a.org/">CS61A官方网站</a>，里面包含了相关的<code>videos</code>、<code>slides</code>和<code>homework</code>帮助你学习！<br>英语和我一样不很出彩的可以观看b站双语翻译版本：<br><a href="https://www.bilibili.com/video/BV1sy411z7nA?spm_id_from=333.788.videopod.sections&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a">【完结】【CS61A精翻双语·英文原声】伯克利大学《计算机程序的结构与解释》(2024)</a></p><h2 id="Functions">Functions</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> &lt;name&gt;(&lt;formal parameters&gt;):<br>    <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">return</span> expression&gt;<br></code></pre></td></tr></tbody></table></figure><p>函数与变量的区别：变量是<strong>一次性赋值</strong>的，函数在<strong>每次调用时会重新计算</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>radius=<span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>area=mul(radius,radius)*pi<br><span class="hljs-meta">&gt;&gt;&gt; </span>area<br><span class="hljs-number">314.1592653589793</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>radius=<span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>area<br><span class="hljs-number">314.1592653589793</span><br></code></pre></td></tr></tbody></table></figure><p>这里我们发现变量<code>area</code>在第一次进行赋值后，尽管<code>radius</code>进行改变，但是其值不再发生变化，可见赋值是一次性的，不是动态的！</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> mul(radius,radius)*pi<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>area()<br><span class="hljs-number">1256.6370614359173</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>radius=<span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>area()<br><span class="hljs-number">314.1592653589793</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>radius=<span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>area()<br><span class="hljs-number">3.141592653589793</span><br></code></pre></td></tr></tbody></table></figure><p>于是我们考虑将<code>area</code>变成函数，发现每次调用<code>area()</code>时，<code>area()</code>都会根据表达式的值重新计算，做到了动态变化！</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>))<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-literal">None</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></tbody></table></figure><table><thead><tr><th>步骤</th><th>代码</th><th>行为</th><th>输出</th></tr></thead><tbody><tr><td>1</td><td><code>print(1)</code></td><td>调用 <code>print(1)</code>，打印 <code>1</code>，返回 <code>None</code></td><td><code>1</code></td></tr><tr><td>2</td><td><code>print(2)</code></td><td>调用 <code>print(2)</code>，打印 <code>2</code>，返回 <code>None</code></td><td><code>2</code></td></tr><tr><td>3</td><td><code>print(None, None)</code></td><td>调用 <code>print(None, None)</code>，打印 <code>None None</code></td><td><code>None None</code></td></tr></tbody></table><p><code>Python</code>会先计算所有参数，再执行外层函数，<code>print()</code>的<strong>返回值永远是 <code>None</code></strong>，但它会先执行打印。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> floordiv,mod<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide_exact</span>(<span class="hljs-params">N,D</span>):<br>    <span class="hljs-string">"""Return the quotient and remainder of dividing N by D.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt;q,r=divide_exact(2013,10)</span><br><span class="hljs-string">    &gt;&gt;&gt;q</span><br><span class="hljs-string">    201</span><br><span class="hljs-string">    &gt;&gt;&gt;r</span><br><span class="hljs-string">    3</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">return</span> floordiv(N,D),mod(N,D)<br></code></pre></td></tr></tbody></table></figure><p>项目中函数的<strong>形式参数用大写字母表示</strong>，提供<strong>文档字符串</strong>：在函数定义<code>def</code>的第一行添加注释，<strong>表明这个函数的作用</strong>，并<strong>添加一个实例说明</strong>（可以在<code>python</code><strong>交互式界面</strong>进行演示）。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">"""Compute the nth Fibonacci number?"""</span><br><br>    pred,curr=<span class="hljs-number">1</span>,<span class="hljs-number">0</span><br>    k=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> k &lt; n:<br>        pred,curr=curr,curr+pred<br>        k=k+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> curr<br></code></pre></td></tr></tbody></table></figure><p>通过<code>while</code>控制语句实现求值斐波那契数列索引的元素值！</p><h2 id="Higher-Order-Functions">Higher-Order Functions</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">"""Generalization."""</span><br><br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi,sqrt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">r,shape_constant</span>):<br>    <span class="hljs-keyword">assert</span> r&gt;<span class="hljs-number">0</span>,<span class="hljs-string">"A length must be positive"</span><br>    <span class="hljs-keyword">return</span> r*r*shape_constant<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">area_square</span>(<span class="hljs-params">r</span>):<br>    <span class="hljs-keyword">return</span> area(r,<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">area_circle</span>(<span class="hljs-params">r</span>):<br>    <span class="hljs-keyword">return</span> area(r,pi)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">area_hexagon</span>(<span class="hljs-params">r</span>):<br>    <span class="hljs-keyword">return</span> area(r,<span class="hljs-number">3</span>*sqrt(<span class="hljs-number">3</span>)/<span class="hljs-number">2</span>)<br></code></pre></td></tr></tbody></table></figure><ol><li><code>assert</code> 的防御性编程作用：<strong>防止非法的负值或零值输入</strong>导致数学错误！</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pythono">assert r &gt; 0, "A length must be positive"<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>将不同图形的面积计算<strong>抽象为统一公式</strong>：<code>r² × 形状系数</code>：</li></ol><ul><li><p><strong>避免为每个图形重复编写</strong><code>r*r</code>的计算逻辑</p></li><li><p>新增图形时<strong>只需提供对应的形状常数</strong>，<strong>无需修改核心算法</strong>，<strong>增强代码整体的泛化能力</strong></p></li><li><p><strong>集中维护输入验证逻辑</strong>（如<code>assert</code>检查）</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">"""Generalization."""</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">identity</span>(<span class="hljs-params">k</span>):<br>    <span class="hljs-keyword">return</span> k<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">k</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(k,<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">summation</span>(<span class="hljs-params">n,term</span>):<br>    <span class="hljs-string">"""Sum the first N terms of a sequence.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; summation(5,cube)</span><br><span class="hljs-string">    225</span><br><span class="hljs-string">    """</span><br>    total,k=<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k&lt;=n:<br>        total,k=total+term(k),k+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> total<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">"""Sum the first N natural numbers.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &lt;&lt;&lt; sum_naturals(5)</span><br><span class="hljs-string">    15</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">return</span> summation(n,identity)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">""" Sum the first N cubes of natural numbers.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; sum_cubes(5)</span><br><span class="hljs-string">    225</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">return</span> summation(n,cube)<br></code></pre></td></tr></tbody></table></figure><p>这里传入的参数<code>term</code>是一个已定义的函数名，我们通过参数<code>term</code>对求和类型进行修改和新定义，而<strong>整体框架无需改动</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">"""Generalization."""</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_adder</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">"""Return a function that takes one argument</span><br><span class="hljs-string">    K and return K+N.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; add_three=make_adder(3)</span><br><span class="hljs-string">    &gt;&gt;&gt; add_three(4)</span><br><span class="hljs-string">    7</span><br><span class="hljs-string">    &gt;&gt;&gt; make_adder(3)(4)</span><br><span class="hljs-string">    7</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">adder</span>(<span class="hljs-params">k</span>):<br>        <span class="hljs-keyword">return</span> k+n<br>    <span class="hljs-keyword">return</span> adder<br></code></pre></td></tr></tbody></table></figure><p>这是一个返回值为函数的函数（函数的嵌套）叫作：</p><ul><li>函数工厂（<code>Factory Pattern</code>）:<br><code>make_adder</code> 是一个 生成函数的函数（工厂）<br>根据参数 n 动态生成不同功能的加法函数</li></ul><p>以上表明函数与编程语言中的其他值一样，可以<strong>作为参数传递</strong>也可以<strong>作为返回值返回</strong>，这就是<strong>高阶函数</strong>(<strong>Higher-Order Function</strong>)。</p><h2 id="Environments">Environments</h2><h3 id="lambda表达式">lambda表达式</h3><p><code>def</code>和<code>lambda</code>表达式的区别：</p><table><thead><tr><th>特性</th><th>Lambda 表达式</th><th>普通函数 (<code>def</code>)</th></tr></thead><tbody><tr><td><strong>语法</strong></td><td>单行匿名表达式：<code>lambda x: x + 1</code></td><td>多行命名定义：<code>def func(x): return x + 1</code></td></tr><tr><td><strong>名称</strong></td><td>匿名（无函数名）</td><td>有函数名（可通过 <code>func.__name__</code> 获取）</td></tr><tr><td><strong>代码复杂度</strong></td><td>仅限单个表达式（不能包含语句）</td><td>可包含多行语句、循环、条件等复杂逻辑</td></tr><tr><td><strong>返回值</strong></td><td>自动返回表达式结果</td><td>需显式使用 <code>return</code></td></tr><tr><td><strong>作用域</strong></td><td>只能访问全局变量和参数</td><td>可访问全局、局部变量，支持闭包</td></tr><tr><td><strong>适用场景</strong></td><td>简单逻辑、临时函数</td><td>复杂逻辑、需复用的功能</td></tr></tbody></table><h3 id="Function-Currying-函数柯里化">Function Currying(函数柯里化)</h3><p>  <strong>柯里化</strong>（<code>Currying</code>）是一种将接受多个参数的函数转换为一系列只接受单个参数的函数链式调用的技术，其核心特点是分步传递参数和延迟计算。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>            <span class="hljs-keyword">return</span> f(x,y)<br>        <span class="hljs-keyword">return</span> h<br>    <span class="hljs-keyword">return</span> g<br></code></pre></td></tr></tbody></table></figure><p>  在这个例子中我们发现柯里化进行了<strong>参数分解</strong>：原始函数<code>f(x,y)</code>需要同时接收两个参数，而柯里化后通过<code>curry(f)</code> 生成的新函数链 <code>g(x)(y)</code> 允许先传<code>x</code>再传 <code>y</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">g</span>):<br>    a=<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> y:a*g(y)<br>f(<span class="hljs-keyword">lambda</span> y:a+y)(a)<br></code></pre></td></tr></tbody></table></figure><p>  在这个例子中，先定义了<code>a=1</code>全局变量（<code>local frame</code>），在函数<code>f</code>内部定义局部变量<code>a=2</code>（<code>global frame</code>）所以结果是（<code>2*(1+1)</code>）！</p><h2 id="Abstraction">Abstraction</h2><p>  函数抽象是给某个计算过程起个名字，然后整个项目过程都引用这个名字，而不用担心具体的实现细节。</p><ul><li>需要知道函数需要<strong>传递几个参数</strong></li><li>需要知道<strong>函数的功能</strong></li><li>不需要知道函数的<strong>实现过程</strong></li></ul><p>比如平方函数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x*x<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> mul<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> mul(x,x-<span class="hljs-number">1</span>)+x<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x,<span class="hljs-number">2</span>)<br></code></pre></td></tr></tbody></table></figure><p>封面来源于<code>CS61A</code>中<code>lecture1</code>的<code>slide</code>，是其标志性的表达式树！</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Essential Sorting Algorithms Explained</title>
    <link href="/2025/07/24/Data%20structure/Essential-Sorting-Algorithms-Explained/"/>
    <url>/2025/07/24/Data%20structure/Essential-Sorting-Algorithms-Explained/</url>
    
    <content type="html"><![CDATA[<p>This article explores some of the most essential sorting algorithms in Datastructure!</p><span id="more"></span><h2 id="题目">题目</h2><p>文章中排序算法均已经通过此题的OJ测试点！</p><h4 id="题目描述">题目描述</h4><p>给你N个自然数，编程输出排序后的这N个数。</p><h4 id="输入">输入</h4><p>第一行是整数的个数N（N&lt;=100）。第二行是用空格隔开的N个数。</p><h4 id="输出">输出</h4><p>排序输出N个数，每个数间用一个空格间隔。</p><h4 id="样例输入">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><hr><p><img src="images%5CEssential-Sorting-Algorithm-Explained%5C%E5%9B%BE%E7%89%871.png" alt="图1 排序算法图"></p><h2 id="1-直接插入排序（Straight-Insertion-Sort）">1.直接插入排序（Straight Insertion Sort）</h2><h3 id="核心思想">核心思想</h3><p>  将待排数组分为“已排序”和“未排序”两个部分，<code>R[0,1...i-1]</code>前面序列是已经排好的有序区，<code>R[i,...n]</code>后面的序列是未排序的无序区，直接插入排序每次操作将当前无序区的首元素<code>R[i]</code>插入到有序区<code>R[0,1...i-1]</code>的适当位置，使得<code>R[0,1...i]</code>成为新的有序区，减小无序区,直至无序区为空，从而全部数据有序！</p><h3 id="完整代码">完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a &lt; b; }<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    vector&lt;<span class="hljs-type">int</span>&gt; R;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        R.<span class="hljs-built_in">push_back</span>(a);<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {<br>        <span class="hljs-type">int</span> temp = R[i];<span class="hljs-comment">//用temp临时存储待排元素</span><br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<span class="hljs-comment">//让temp从i-1开始逐个向前比较</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">cmp</span>(temp, R[j])) {<br>                R[j + <span class="hljs-number">1</span>] = R[j];<br>                j--;<br>            }<br>            R[j + <span class="hljs-number">1</span>] = temp;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        cout &lt;&lt; R[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>} <br></code></pre></td></tr></tbody></table></figure><p>这里将比较逻辑模块化：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a &gt; b; }  <br></code></pre></td></tr></tbody></table></figure><p>若未来需要修改排序规则（降序排序）只需要将<code>cmp</code>函数中的<code>&gt;</code>修改为<code>&lt;</code>即可！</p><h3 id="算法分析">算法分析</h3><p>  直接插入排序由<strong>两重循环</strong>构成，对于具有<code>n</code>个元素的数组<code>R</code>，外循环要进行<code>n-1</code>趟排序（<code>1到n-1</code>），在每趟排序中，仅当待插入序列元素<code>R[i]</code>小于有序区尾元素时才进入内层循环，因此直接插入排序的<strong>时间性能与初始排序表相关</strong>。</p><ul><li>比较次数</li><li>元素移动次数</li></ul><ol><li>最好情况分析：初始排序表正序，无需进入内层循环时间复杂度为<code>O(n)</code></li><li>最坏情况分析：初始排序表反序，每次排序均需要进入内层循环进行<code>i</code>次比较，等差数列<code>n(n-1)/2</code>，时间复杂度为<code>O(n^2)</code></li><li>平均情况分析：在每趟排序中，平均情况是将<code>R[i]</code>插入到有序区的中间位置<code>R[0,1...i-1]</code>，等差数列<code>n(n-1)/4</code>，时间复杂度为<code>O(n^2)</code>。</li></ol><p>  由于其<strong>平均时间性能接近最坏性能</strong>，所以是一种<strong>低效</strong>的排序方法。在该算法中只使用了<code>i</code>,<code>j</code>,<code>temp</code>三个辅助变量，与问题规模<code>n</code>无关，故空间复杂度为<code>O(1)</code>，是一个<strong>就地排序</strong>算法，同时相等时排序不变，是种<strong>稳定</strong>的排序算法。</p><hr><h2 id="2-折半插入排序（Binary-Insertion-Sort）">2.折半插入排序（Binary Insertion Sort）</h2><h3 id="核心思想-v2">核心思想</h3><p>  在直接插入排序的基础上，用折半查找的方法找到无序区元素插入的位置。</p><h3 id="完整代码-v2">完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    vector&lt;<span class="hljs-type">int</span>&gt; R; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        <span class="hljs-type">int</span> a;<br>        cin &gt;&gt; a;<br>        R.<span class="hljs-built_in">push_back</span>(a); <br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {<br>        <span class="hljs-type">int</span> temp = R[i];<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) {<span class="hljs-comment">//退出循环时low=high+1</span><br>            <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (temp &gt; R[mid]) {<br>                low = mid + <span class="hljs-number">1</span>;<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                high = mid - <span class="hljs-number">1</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= high + <span class="hljs-number">1</span>; j--) {  <br>            R[j + <span class="hljs-number">1</span>] = R[j];<br>        }<br>        R[high + <span class="hljs-number">1</span>] = temp;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        cout &lt;&lt; R[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="算法分析-v2">算法分析</h3><p>  平均情况下时间复杂度为<code>O(n^2)</code>,从时间复杂度来看，折半插入与直接插入排序相同，但是当<strong>元素数量较多时，折半查找优于顺序查找</strong>，减少了关键字比较的次数，所以折半插入排序优于直接插入排序。同时其空间复杂度为<code>O(1)</code>，也是种<strong>稳定</strong>的排序算法。</p><hr><h2 id="3-希尔排序（Shell-Sort）">3.希尔排序（Shell Sort）</h2><h3 id="核心思想-v3">核心思想</h3><p>  希尔排序是一种<strong>采用分组插入排序</strong>的方法，先取一个小于<code>n</code>的整数${d}<em>{1}$作为第一个增量，将全部元素<code>R</code>中所有相距为 ${d}</em>{1}$的元素分成一组，在组内进行直接插入排序，然后取第二个增量 ${d}<em>{2}$（${d}</em>{2}$&lt;${d}<em>{1}$），重复上述的分组和排序，直至增量 ${d}</em>{t}$=1，即<strong>所有的元素为一组，在进行一次直接插入排序</strong>，从而使得所有元素有序！<br>  从理论上讲，增量序列的取值只要满足初始值小于<code>n</code>再递减并且最后等于<code>1</code>就可以了。最常见的是<strong>Shell增量序列</strong>，即取 ${d}<em>{1}$=<code>n/2</code>，${d}</em>{i+1}$=${d}<em>{i}$/2，直到 ${d}</em>{t}$=0为止！</p><h3 id="完整代码-v3">完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>vector &lt;<span class="hljs-type">int</span>&gt; R;<br><span class="hljs-type">int</span> N;<br>cin &gt;&gt; N;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) {<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>R.<span class="hljs-built_in">push_back</span>(a);<br>}<br><span class="hljs-type">int</span> d = N / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (d != <span class="hljs-number">0</span>) {<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= d;i&lt; N;i++) {<br><span class="hljs-type">int</span> temp = R[i];<br><span class="hljs-type">int</span> j = i;<br><span class="hljs-keyword">while</span> (j &gt;= d &amp;&amp; R[j - d] &gt; temp) {<br>R[j] = R[j - d];<br>j -= d;<br>}<br>R[j] = temp;<br>}<br>d /= <span class="hljs-number">2</span>;<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) {<br>cout &lt;&lt; R[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="算法分析-v3">算法分析</h3><p>  由于希尔排序的增量序列不确定，算法的时间复杂度难以分析，我们一般认为其平均时间复杂度为<code>O(n^1.58)</code>，<strong>希尔排序通常要比直接插入排序快</strong>，在希尔排序中我们使用了<code>i</code>,<code>j</code>,<code>temp</code>,<code>d</code>四个辅助变量，与问题规模<code>n</code>无关，故算法空间复杂度为<code>O(1)</code>，也就是说是一种<strong>就地排序</strong>。但是希尔排序过程中相同元素的相对位置可能发生变化，因而是一种<strong>不稳定</strong>的排序算法。</p><hr><h2 id="4-快速排序（Quick-Sort）">4.快速排序（Quick Sort）</h2><h3 id="核心思想-v4">核心思想</h3><p>  在排序表中取一个元素为基准（一般是第一个），<strong>将基准归位</strong>（即将基准放在他最终的位置上），同时将所有小于基准的元素放到基准的前面（构成<strong>左子表</strong>），将所有大于基准的元素放到基准的后面（构成<strong>右子表</strong>），这个过程叫作<strong>划分</strong>。然后用递归的思想对左、右子表分别重复上述过程，直至每个子表只有一个元素或空为止。<br>  快速排序每次<strong>仅将一个元素归位</strong>，在最后一趟排序结束前并不产生明确的连续有序区。</p><h3 id="完整代码-v4">完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt;&amp;arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br><span class="hljs-type">int</span> base = arr[low];<br><span class="hljs-type">int</span> i = low + <span class="hljs-number">1</span>, j = high;<br><span class="hljs-keyword">while</span> (i &lt;= j) {<br><span class="hljs-keyword">while</span> ( i &lt;= j &amp;&amp; arr[i] &lt;= base) {<br>i++;<br>}<br><span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; arr[j] &gt;= base) {<br>j--;<br>}<br><span class="hljs-keyword">if</span> (i &lt; j) {<br><span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>i++;<br>j--;<br>}<br>}<br><span class="hljs-built_in">swap</span>(arr[low], arr[j]);<br><span class="hljs-keyword">return</span> i;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br><span class="hljs-keyword">if</span> (low &gt;= high)<span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, low, high);<br><span class="hljs-built_in">quicksort</span>(arr, low, pi<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">quicksort</span>(arr, pi<span class="hljs-number">+1</span>, high);<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>vector &lt;<span class="hljs-type">int</span>&gt; R;<br><span class="hljs-type">int</span> N;<br>cin &gt;&gt; N;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) {<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>R.<span class="hljs-built_in">push_back</span>(a);<br>}<br><span class="hljs-built_in">quicksort</span>(R, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) {<br>cout &lt;&lt; R[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="算法分析-v4">算法分析</h3><ol><li>最好情况分析：如果初始排序表随机分布，使得<strong>每次划分恰好分为两个长度相同的子表</strong>，则递归树最小，性能最好，此时排序的时间复杂度为<code>O(nlog2n)</code>。</li><li>最坏情况分析：如果初始排序表<strong>正序或反序</strong>，使得<strong>每次划分的两个子表中一个为空</strong>，另一个长度为<code>n-1</code>，则递归树的高度最高，性能最差，此时排序的时间复杂度为<code>O(n^2)</code>。</li><li>平均情况分析：排序的平均时间复杂度为<code>O(nlog2n)</code>，这<strong>接近最好情况</strong>，所以快速排序是一种<strong>高效</strong>的排序方法。</li></ol><p>  快速排序使用的是<strong>递归算法</strong>，尽管每一次划分仅仅使用固定的几个辅助变量，但是<strong>递归树的高度</strong>最好为<code>O(log2n)</code>，对应最好的空间复杂度为<code>O(log2n)</code>，最坏情况下递归树的高度为<code>O(n)</code>，对应最坏的空间复杂度为<code>O(n)</code>。<br>  另外，快速排序是一种<strong>不稳定</strong>的排序算法。（STL的<code>sort()</code>函数就是使用快速排序实现的，当划分的区间长度较小时，采用直接插入排序，所以<code>sort()</code>是不稳定的，且时间复杂度为<code>O(nlog2n)</code>）</p><hr><h2 id="5-堆排序（Heap-Sort）">5.堆排序（Heap Sort）</h2><h3 id="核心思想-v5">核心思想</h3><p>  堆排序是对<strong>选择排序的一种改进</strong>，采用<strong>二叉树</strong>来代替简单的选择方法来找最大或者最小元素，属于一种<strong>树形选择排序方法</strong>。我们采用数组隐式构建二叉树：</p><ol><li>小根堆：根节点小于其两个子节点，即：${k}<em>{i}$$\leq$${k}</em>{2i+1}$ 且 ${k}<em>{i}$$\leq$${k}</em>{2i+2}$，显然此时根节点是最小的。</li><li>大根堆：根节点大于其两个子节点，即：${k}<em>{i}$$\geq$${k}</em>{2i+1}$ 且 ${k}<em>{i}$$\geq$${k}</em>{2i+2}$，显然此时根节点是最大的。</li></ol><h3 id="完整代码-v5">完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> root)</span> </span>{<br>    <span class="hljs-type">int</span> largest = root; <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * root + <span class="hljs-number">1</span>; <br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * root + <span class="hljs-number">2</span>; <br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])<br>        largest = left;<br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])<br>        largest = right;<br>    <span class="hljs-keyword">if</span> (largest != root) {<br>        <span class="hljs-built_in">swap</span>(arr[root], arr[largest]);<br>        <span class="hljs-built_in">heapify</span>(arr, n, largest);<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>{<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">heapify</span>(arr, n, i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        cin &gt;&gt; arr[i];<br>    }<br>    <span class="hljs-built_in">heapSort</span>(arr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; arr[i];<br>    }<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="算法分析-v5">算法分析</h3><p>  堆排序的时间主要由<strong>建立初始堆</strong>和<strong>反复重建堆</strong>这两部分的时间构成，建立初始堆的时间复杂度为<code>O(nlog2n)</code>，后面反复归位元素和重建堆的时间复杂度为<code>O(nlog2n)</code>，因此最好、最坏、平均时间复杂度均为<code>O(nlog2n)</code>。<br>  堆排序只使用了固定的几个辅助变量，其算法的空间复杂度为<code>O(1)</code>，同时是一种<strong>不稳定</strong>的排序算法。</p><hr><h2 id="6-归并排序（Merge-Sort）">6.归并排序（Merge Sort）</h2><h3 id="核心思想-v6">核心思想</h3><p>  通过多次将两个或两个以上的相邻有序表合并成一个新的有序表。可以分为二路归并、三路归并、多路归并排序。其中二路归并排序又可以分为<strong>自底向上</strong>和<strong>自顶向下</strong>两种方法。<br>  二路归并先将<code>R[0...n-1]</code>看成<code>n</code>个长度为<code>1</code>的有序子表，然后在进行两两相邻有序子表的合并，得到<code>n/2</code>个长度为<code>2</code>的有序子表，在进行<strong>两两有序子表的合并</strong>，以此类推，直到得到一个长度为<code>n</code>的有序表为止。<br>  二路归并时，先将两段有序<strong>合并到一个新的局部变量</strong><code>R1</code>中，待合并完成后再将<code>R1</code><strong>复制回</strong><code>R</code>中。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>{<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) {<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) {<br>            temp[k++] = arr[i++];<br>        }<br>        <span class="hljs-keyword">else</span> {<br>            temp[k++] = arr[j++];<br>        }<br>    }<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) {<br>        temp[k++] = arr[i++];<br>    }<br>    <span class="hljs-keyword">while</span> (j &lt;= right) {<br>        temp[k++] = arr[j++];<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; k; p++) {<br>        arr[left + p] = temp[p];<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>{<br>    <span class="hljs-keyword">if</span> (left &gt;= right) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(arr, left, mid);      <br>    <span class="hljs-built_in">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, right); <br>    <span class="hljs-built_in">merge</span>(arr, left, mid, right); <br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        cin &gt;&gt; arr[i];<br>    }<br>    <span class="hljs-built_in">mergeSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; arr[i];<br>    }<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="算法分析-v6">算法分析</h3><p>  在二路归并排序中，长度为<code>n</code>的排序表需要做<code>log2n</code>趟排序，对应的<strong>归并树</strong>高度为<code>log2n+1</code>，每趟归并时间为<code>O(n)</code>，故其时间复杂度的最好、最坏、平均情况都是<code>O(nlog2n)</code>。<br>  在归并排序中每次都需要用到<strong>局部变量</strong><code>R1</code>，最后一趟的排序一定是全部<code>n</code>个元素参与归并，所以总的辅助空间复杂度为<code>O(n)</code>。<br>  同时<code>Merge</code>算法不会改变相同关键字元素的相对次序，所以二路归并算法是一种<strong>稳定</strong>的排序方法！</p><hr><p>有关<strong>冒泡排序</strong>、<strong>选择排序</strong>和<code>sort()</code>函数排序的相关代码在：<a href="https://blog.csdn.net/2401_86849688/article/details/148566285?spm=1001.2014.3001.5501">数据结构实验2</a>中，有兴趣的可以直接传送门！</p><hr><h2 id="各种排序方法的比较和选择">各种排序方法的比较和选择</h2><table><thead><tr><th>排序方法</th><th>平均情况</th><th>最坏情况</th><th>最好情况</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n^1.58)</td><td>\</td><td>\</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlog2n)</td><td>O(n^2)</td><td>O(nlog2n)</td><td>O(log2n)</td><td>不稳定</td></tr><tr><td>简单选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n)</td><td>稳定</td></tr></tbody></table><p>封面来源：<a href="https://www.youtube.com/watch?v=AAwYzYkjNTg">Explaining EVERY Sorting Algorithm (part 1)</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Classes and Objects in C++</title>
    <link href="/2025/07/22/CPP/Classes-and-Objects-in-C++/"/>
    <url>/2025/07/22/CPP/Classes-and-Objects-in-C++/</url>
    
    <content type="html"><![CDATA[<p>This post dives deep into object-oriented programming (OOP), the true essence of C++!</p><span id="more"></span> <div class="note note-primary">            <p>看到过一个很讽刺的笑话：大多数国内高校学生学到的CPP只是<strong>C语言的cin/cout</strong>。这当然只是一句玩笑话，但很深刻地反映出对于<strong>CPP精髓面向对象编程</strong>的忽视。这是有理可依的：编程语言的学习本身就和传统的课堂授课模式存在较大的出入，<strong>编程重视实践</strong>，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较<strong>大规模的项目工程</strong>，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态··· ”，很容易将CPP学成死记硬背的无聊学科。</p>          </div><p>因此，笔者希望通过博客的方式，记录自己<strong>OOP in CPP</strong>的学习笔记，并分享给各位小伙伴！</p><h1>Why OOP?</h1><ul><li><p>面向过程的局限性：将描述事物的数据与处理数据的函数分开。</p><ul><li>若所描述事物的数据结构发生变化时，这些成员函数也必须重新设计！</li><li>在主函数中对数据进行修改，仅仅需要执行一条赋值语句，数据安全性得不到保障！</li></ul></li><li><p>面向对象的优势：将描述事物的数据与处理函数<strong>封装</strong>成一个整体，称为类。</p><ul><li>封装在类中的函数和数据不受外界的影响，即类使数据具有良好的<strong>独立性</strong>和<strong>可维护性</strong>！</li><li>类中的数据在类的外部不能直接调用，外部只能通过<strong>公共接口函数</strong>来处理类中的数据，从而保障了<strong>数据的安全性</strong>！</li></ul></li></ul><h1>类和对象</h1><h2 id="类：">类：</h2><p>  类描述了某一类事物应该具有哪些<strong>特征</strong>和<strong>行为</strong>。比如我们想描述一个“商品”类别，类就会告诉我们商品的名称、编号、进货价格、售出价格等特征，但是这个“商品”并不是一真正的商品，类只告诉了我们“商品”是什么样的、应该具有的特征。类是对象的抽象表示，它<strong>本身不占用内存空间</strong>。</p><p>类<code>class</code>与结构体<code>struct</code>形式相似，关键字不同！</p><ul><li><code>class</code>的成员默认是<code>private</code>的</li><li><code>struct</code>的成员默认是<code>public</code>的</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">class</span> 类名 {<br>     <span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//私有数据成员和成员函数</span><br>     <span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">//保护数据成员和成员函数</span><br>     <span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//共有数据成员和成员函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><ul><li><code>private</code>:只能被类本身的成员函数、友元函数、友元函数的成员函数访问，派生类也无法访问。</li><li><code>protected</code>:除派生类可以进行访问，其余与<code>private</code>相同。</li><li><code>public</code>:可以被程序中任意代码访问。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cgoods</span>{<span class="hljs-comment">//商品类</span><br>     <span class="hljs-keyword">private</span>:<br>        string ID; <span class="hljs-comment">//商品编号</span><br>        string name; <span class="hljs-comment">//商品名称</span><br>        <span class="hljs-type">double</span> Purchasingprice; <span class="hljs-comment">//进货价格</span><br>        <span class="hljs-type">double</span> Sellingprice; <span class="hljs-comment">//售出价格</span><br>        <span class="hljs-type">int</span> SellCount; <span class="hljs-comment">//售出数量</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">double</span> Profit; <span class="hljs-comment">//总利润</span><br>     <span class="hljs-keyword">protected</span>:<span class="hljs-comment">//无</span><br>     <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">cgoods</span>(string id, string name, <span class="hljs-type">double</span> purchasingprice){<span class="hljs-comment">//构造函数</span><br>        <span class="hljs-comment">//函数体</span><br>        }<br>        ~<span class="hljs-built_in">cgoods</span>(){<span class="hljs-comment">//析构函数</span><br>        } <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetPurchasingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> purchasingprice)</span></span>{<span class="hljs-comment">//设置进货价格</span><br>        <span class="hljs-comment">//函数体</span><br>        }<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetSellingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> sellingprice)</span></span>{<span class="hljs-comment">//设置出货价格</span><br>        <span class="hljs-comment">//函数体</span><br>        }<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSellingcount</span><span class="hljs-params">(<span class="hljs-type">int</span> sellcount)</span></span>{<span class="hljs-comment">//设置出货商品价格</span><br>        <span class="hljs-comment">//函数体</span><br>        }<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sell</span><span class="hljs-params">(<span class="hljs-type">double</span> sellingprice,<span class="hljs-type">int</span> sellcount)</span></span>{<br>        <span class="hljs-comment">//函数体</span><br>        }<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">getProfit</span><span class="hljs-params">()</span></span>{<span class="hljs-comment">//获取总利润，静态成员函数</span><br>        <span class="hljs-comment">//函数体</span><br>        }<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>{<br>        <span class="hljs-comment">//函数体</span><br>        }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="对象：">对象：</h2><p>  对象则是根据类创建出来的具体实例。比如我们创建一个叫“手机”的“商品”，他有自己的具体的编号、进货价格、售出价格等，所有的特征都是独一无二的，不会与其他商品相同。每一个对象都是根据类创建的具有其属性和方法的实例，并且具有唯一的身份标识（如内存地址）和自己独特的属性值。 <strong>对象是占用内存空间的</strong>，它的<strong>属性值可以在运行时动态地改变</strong>。</p><p>定义对象的三种方法：</p><ul><li>先定义类的类型，再定义对象：</li></ul> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 类名{<br>    成员表;<br>};<br>[<span class="hljs-keyword">class</span>]可选 类名 对象名列表;<br></code></pre></td></tr></tbody></table></figure><p>例如：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">class</span> cgoods <span class="hljs-title">goods1</span><span class="hljs-params">(<span class="hljs-string">"1001001"</span>,<span class="hljs-string">"元气森林"</span>)</span></span>;<span class="hljs-comment">//创建对象goods1</span><br><span class="hljs-function">cgoods <span class="hljs-title">goods</span><span class="hljs-params">(<span class="hljs-string">"1001001"</span>,<span class="hljs-string">"元气森林"</span>)</span></span>;<span class="hljs-comment">//两种方法等价</span><br></code></pre></td></tr></tbody></table></figure><ul><li>在定义类类型时<strong>同时创建对象</strong>：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 类名{<br>    成员表;<br>}对象名表;<br></code></pre></td></tr></tbody></table></figure><p>例如：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cgoods</span>{<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">public</span>:<br>}<span class="hljs-built_in">goods1</span>(<span class="hljs-string">"1001001"</span>,<span class="hljs-string">"元气森林"</span>)；<br></code></pre></td></tr></tbody></table></figure><ul><li>不出现类名<strong>直接定义对象</strong>：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> {<br>     成员表;<br> }对象名表;<br></code></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> {<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">public</span>:<br>}<span class="hljs-built_in">goods1</span>(<span class="hljs-string">"1001001"</span>,<span class="hljs-string">"元气森林"</span>)；<br></code></pre></td></tr></tbody></table></figure><p>此方法由于没有类名，所以只能<strong>一次性声明多个对象</strong>，此后再无法声明此类对象！</p><h2 id="类的成员访问">类的成员访问</h2><ul><li>对于数据成员的访问</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">对象名.成员名<span class="hljs-comment">//数据成员访问</span><br>对象指针名-&gt;成员名<br>(*对象指针名).成员名<br></code></pre></td></tr></tbody></table></figure><ul><li>对于成员函数的访问</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">对象名.成员函数名(参数表)<span class="hljs-comment">//成员函数访问</span><br>对象指针名-&gt;成员函数名(参数表)<br>(*对象指针名).成员函数名(参数表)<br></code></pre></td></tr></tbody></table></figure><h2 id="类的构造函数-Constructor">类的构造函数(Constructor)</h2><ul><li>类的对象太过复杂，一个对象可能有许许多多的数据成员，这就意味着我们要对许许多多的数据成员进行初始化，实现这一过程并不容易。构造函数的作用就是在对象被创建时<strong>利用特定的初始值</strong>构造对象，把对象<strong>置于某一个初始状态</strong>。</li></ul><ol><li>有<strong>与类完全相同的名字</strong></li><li><strong>没有类型说明</strong>，不允许有返回值</li><li><strong>可以进行重载</strong>，即一个类中允许定义多个参数不同的构造函数</li><li>可以在声明时的<strong>参数表里给予初始值</strong></li><li>每个类都必须至少有一个构造函数，如果没有显式的为类提供构造函数，则C++<strong>提供一个默认的无参构造函数</strong>，只负责对象的创建，而不做任何初始化的工作</li><li>一旦类定义了构造函数，C++不再提供默认的无参构造函数</li><li>程序中不能直接调用构造函数，他是在<strong>创建类的对象时自动调用</strong>的</li></ol><hr><h3 id="1-无参构造函数">1. 无参构造函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Time</span>() { <span class="hljs-comment">// 定义构造成员函数，函数名与类名相同</span><br>        hour = <span class="hljs-number">22</span>;<br>        minute = <span class="hljs-number">22</span>;<br>        sec = <span class="hljs-number">22</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_time</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 函数声明</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 函数声明</span><br><span class="hljs-keyword">private</span>: <span class="hljs-comment">// 私有数据成员</span><br>    <span class="hljs-type">int</span> hour;<br>    <span class="hljs-type">int</span> minute;<br>    <span class="hljs-type">int</span> sec;<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Time::set_time</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 定义成员函数，向数据成员赋值</span><br>    cin &gt;&gt; hour;<br>    cin &gt;&gt; minute;<br>    cin &gt;&gt; sec;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Time::show_time</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 定义成员函数，输出数据成员的值</span><br>    cout &lt;&lt; <span class="hljs-string">"时间为: "</span> &lt;&lt; hour &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; sec &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Time t1;       <span class="hljs-comment">// 建立对象t1，同时调用构造函数t1.Time()</span><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">set_time</span>(); <span class="hljs-comment">// 对t1的数据成员赋值</span><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">show_time</span>(); <span class="hljs-comment">// 显示t1的数据成员的值</span><br>    Time t2;       <span class="hljs-comment">// 建立对象 t2，同时调用构造函数 t2.Time()</span><br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">show_time</span>(); <span class="hljs-comment">// 显示t2的数据成员的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">12 30 40<br><span class="hljs-section">时间为: 12:30:40</span><br><span class="hljs-section">时间为: 22:22:22</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2-含参构造函数">2. 含参构造函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">构造函数名（类型<span class="hljs-number">1</span> 形参<span class="hljs-number">1</span>，类型<span class="hljs-number">2</span> 形参<span class="hljs-number">2</span>，...）<br>类名 对象名（实参<span class="hljs-number">1</span>，实参<span class="hljs-number">2</span>，...）<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cuboid</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>);  <span class="hljs-comment">// 带有三个参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-type">int</span> length;<br>};<br><br><span class="hljs-comment">// 构造函数的实现</span><br>Cuboid::<span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len) {<br>    height = h;<br>    width = w;<br>    length = len;<br>}<br><br><span class="hljs-comment">// volume成员函数的实现</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cuboid::volume</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> (height * width * length);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">Cuboid <span class="hljs-title">cuboid1</span><span class="hljs-params">(<span class="hljs-number">15</span>, <span class="hljs-number">45</span>, <span class="hljs-number">30</span>)</span></span>;  <span class="hljs-comment">// 定义对象时需要根据构造函数形参提供实参</span><br>    cout &lt;&lt; <span class="hljs-string">"cuboid1的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">1.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br><br>    <span class="hljs-function">Cuboid <span class="hljs-title">cuboid2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">22</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">"cuboid2的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">2.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cuboid1</span>的体积为: <span class="hljs-number">20250</span><br><span class="hljs-attribute">cuboid2</span>的体积为: <span class="hljs-number">6600</span><br></code></pre></td></tr></tbody></table></figure><h3 id="3-构造函数重载">3. 构造函数重载</h3><p>定义多个构造函数以便给对象提供不同的初始化方法，这些构造函数具有相同的名字而<strong>参数的个数或参数的类型不相同</strong>。可以为一个类声明的构造函数的个数是<strong>无限制的</strong>，只要每个构造函数的<strong>形参表是唯一的</strong>，定义对象时会根据提供的实参决定调用哪一个构造函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cuboid</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cuboid</span>();                  <span class="hljs-comment">// 默认构造函数（无参数）</span><br>    <span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len);  <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">// 计算体积方法</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> height;   <span class="hljs-comment">// 高度</span><br>    <span class="hljs-type">int</span> width;    <span class="hljs-comment">// 宽度</span><br>    <span class="hljs-type">int</span> length;   <span class="hljs-comment">// 长度</span><br>};<br><br><span class="hljs-comment">// 默认构造函数实现</span><br>Cuboid::<span class="hljs-built_in">Cuboid</span>() {<br>    height = <span class="hljs-number">15</span>;<br>    width = <span class="hljs-number">15</span>;<br>    length = <span class="hljs-number">15</span>;<br>}<br><br><span class="hljs-comment">// 带参数的构造函数实现</span><br>Cuboid::<span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len) {<br>    height = h;<br>    width = w;<br>    length = len;<br>}<br><br><span class="hljs-comment">// 体积计算方法实现</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cuboid::volume</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> (height * width * length);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 创建对象cuboid1，使用默认构造函数</span><br>    Cuboid cuboid1;<br>    cout &lt;&lt; <span class="hljs-string">"cuboid1的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">1.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">// 创建对象cuboid2，使用带参数的构造函数</span><br>    <span class="hljs-function">Cuboid <span class="hljs-title">cuboid2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">"cuboid2的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">2.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cuboid1</span>的体积为: <span class="hljs-number">3375</span><br><span class="hljs-attribute">cuboid2</span>的体积为: <span class="hljs-number">27000</span><br></code></pre></td></tr></tbody></table></figure><h3 id="4-使用默认值的构造函数">4. 使用默认值的构造函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cuboid</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> height;   <span class="hljs-comment">// 高度</span><br>    <span class="hljs-type">int</span> width;    <span class="hljs-comment">// 宽度</span><br>    <span class="hljs-type">int</span> length;   <span class="hljs-comment">// 长度</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> h = <span class="hljs-number">15</span>, <span class="hljs-type">int</span> w = <span class="hljs-number">15</span>, <span class="hljs-type">int</span> len = <span class="hljs-number">15</span>); <span class="hljs-comment">// 构造函数，全部参数带默认值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 计算体积</span><br>};<br><br><span class="hljs-comment">// 构造函数实现（定义时可不再指定默认值）</span><br>Cuboid::<span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len) {<br>    height = h;   <br>    width = w;<br>    length = len;<br>}<br><br><span class="hljs-comment">// 计算体积方法实现</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cuboid::volume</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> (height * width * length);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Cuboid cuboid1; <span class="hljs-comment">// 没有给出实参，使用全部默认值 height=15,width=15,length=15</span><br>    cout &lt;&lt; <span class="hljs-string">"cuboid1的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">1.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br><br>    <span class="hljs-function">Cuboid <span class="hljs-title">cuboid2</span><span class="hljs-params">(<span class="hljs-number">25</span>)</span></span>; <span class="hljs-comment">// 只给定一个实参，height=25,width=15,length=15</span><br>    cout &lt;&lt; <span class="hljs-string">"cuboid2的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">2.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br><br>    <span class="hljs-function">Cuboid <span class="hljs-title">cuboid3</span><span class="hljs-params">(<span class="hljs-number">25</span>, <span class="hljs-number">40</span>)</span></span>; <span class="hljs-comment">// 只给定2个实参，height=25,width=40,length=15</span><br>    cout &lt;&lt; <span class="hljs-string">"cuboid3的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">3.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br><br>    <span class="hljs-function">Cuboid <span class="hljs-title">cuboid4</span><span class="hljs-params">(<span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)</span></span>; <span class="hljs-comment">// 给定3个实参，height=25,width=30,length=40</span><br>    cout &lt;&lt; <span class="hljs-string">"cuboid4的体积为: "</span> &lt;&lt; cuboid<span class="hljs-number">4.</span><span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cuboid1</span>的体积为: <span class="hljs-number">3375</span><br><span class="hljs-attribute">cuboid2</span>的体积为: <span class="hljs-number">5625</span><br><span class="hljs-attribute">cuboid3</span>的体积为: <span class="hljs-number">15000</span><br><span class="hljs-attribute">cuboid4</span>的体积为: <span class="hljs-number">30000</span><br></code></pre></td></tr></tbody></table></figure><h3 id="5-子对象和构造函数">5.子对象和构造函数</h3><p>在定义一个新的类时，<strong>将一个已有类作为数据成员</strong>，这个类对象叫做子对象。我们通过调用子对象成员的构造函数来完成对子对象的初始化。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> {  <span class="hljs-comment">// 定义矩形类</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Width, Length;  <span class="hljs-comment">// 宽度、长度</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len) {  <span class="hljs-comment">// 带参构造函数</span><br>        Width = w;<br>        Length = len;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Area</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">// 计算面积</span><br>        <span class="hljs-keyword">return</span> (Width * Length);<br>    }<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cuboid</span> {  <span class="hljs-comment">// 定义长方体类</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Height;  <span class="hljs-comment">// 高度</span><br>    Rectangle r;  <span class="hljs-comment">// 使用Rectangle类对象作为成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> h) : <span class="hljs-built_in">r</span>(w, len) {  <span class="hljs-comment">// 初始化列表初始化r对象</span><br>        Height = h;  <span class="hljs-comment">// 原代码这里是Height-h，应该是赋值=</span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Volume</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">// 计算体积</span><br>        <span class="hljs-keyword">return</span> (Height * r.<span class="hljs-built_in">Area</span>());<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">Cuboid <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>)</span></span>;  <span class="hljs-comment">// 创建长方体对象</span><br>    cout &lt;&lt; <span class="hljs-string">"长方体 c1 的体积是: "</span> &lt;&lt; c<span class="hljs-number">1.</span><span class="hljs-built_in">Volume</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">长方体 <span class="hljs-built_in">c1</span> 的体积是: <span class="hljs-number">20000</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> h) : <span class="hljs-built_in">r</span>(w, len) {  <span class="hljs-comment">// 初始化列表初始化r对象</span><br>       Height = h;  <span class="hljs-comment">// 原代码这里是Height-h，应该是赋值=</span><br>   }<br></code></pre></td></tr></tbody></table></figure><p>实参10、20通过<code>w</code>和<code>len</code>赋值<code>r(w, len)</code>，调用类的成员<code>Rectangle(int w, int len)</code>构造函数完成初始化，实参100通过<code>Height = h</code>完成对<code>Cuboid</code>的初始化。</p><h3 id="6-拷贝构造函数">6.拷贝构造函数</h3><p>设计拷贝构造函数<strong>实现类中的一个对象给另一个对象的每个非静态数据成员赋值</strong>。（<strong>用已经初始化的对象去初始化一个新定义的对象</strong>）</p><ol><li>拷贝构造函数的函数名必须<strong>与类名一致</strong>，函数的形式参数是本类型的一个<strong>引用变量</strong>，必须为<strong>引用</strong>！</li><li><strong>自定义拷贝构造函数</strong>，能够实现<strong>有选择</strong>的复制原对象中的数据（实现对部分数据的修改）</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span> {        <span class="hljs-comment">// 定义Sample类</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> nTest;        <span class="hljs-comment">// 私有成员变量，用于存储测试值</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，初始化nTest</span><br>    <span class="hljs-built_in">Sample</span>(<span class="hljs-type">int</span> ly) {  <span class="hljs-comment">// 参数ly用于初始化nTest</span><br>        nTest = ly;   <span class="hljs-comment">// 将参数值赋给成员变量</span><br>    }<br>    <br>    <span class="hljs-comment">// 自定义的拷贝构造函数</span><br>    <span class="hljs-built_in">Sample</span>(Sample &amp;tS) {  <span class="hljs-comment">// 参数是对另一个Sample对象的引用</span><br>        cout &lt;&lt; <span class="hljs-string">"拷贝构造函数被调用"</span> &lt;&lt; endl;  <span class="hljs-comment">// 输出提示信息</span><br>        nTest = tS.nTest + <span class="hljs-number">8</span>;  <span class="hljs-comment">// 新对象的nTest值 = 原对象值 + 8</span><br>    }<br>    <br>    <span class="hljs-comment">// 获取nTest值的成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readtest</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> nTest;  <span class="hljs-comment">// 返回当前对象的nTest值</span><br>    }<br>    <br>    <span class="hljs-comment">// 设置nTest值的成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">settest</span><span class="hljs-params">(<span class="hljs-type">int</span> ly)</span> </span>{<br>        nTest = ly;    <span class="hljs-comment">// 修改当前对象的nTest值</span><br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">Sample <span class="hljs-title">S1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;    <span class="hljs-comment">// 创建S1对象，nTest初始化为100</span><br>    <span class="hljs-function">Sample <span class="hljs-title">S2</span><span class="hljs-params">(S1)</span></span>;     <span class="hljs-comment">// 使用拷贝构造函数创建S2对象</span><br>    cout &lt;&lt; S<span class="hljs-number">2.</span><span class="hljs-built_in">readtest</span>() &lt;&lt; endl;  <span class="hljs-comment">// 输出S2的nTest值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">拷贝构造函数被调用<br>108<br></code></pre></td></tr></tbody></table></figure><h2 id="类的析构函数-Destructor">类的析构函数(Destructor)</h2><p>相当于创建对象时用new申请了一片内存空间，应在退出前<strong>在析构函数中用delete释放</strong>。析构函数是与构造函数作用相反的函数，当对象生命周期结束时，自动执行析构函数。</p><ol><li>有与类完全相同的名字，只是在<strong>函数名前面加一个位取反符“~”</strong>，以区别于构造函数</li><li>不带任何参数，没有返回值</li><li>一个类最多只能有一个析构函数，<strong>无法进行重载</strong></li><li>如果用户没有编写析构函数，编译系统会<strong>自动的生成一个默认的析构函数</strong></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 类名{<br>    <span class="hljs-keyword">public</span>:<br>    ~类名();{<span class="hljs-comment">//析构函数</span><br>    <span class="hljs-comment">//函数体</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//私有数据成员</span><br>    string name;    <span class="hljs-comment">//姓名</span><br>    <span class="hljs-type">int</span> age;        <span class="hljs-comment">//年龄</span><br>    <span class="hljs-type">char</span> gender;    <span class="hljs-comment">//性别，'f'女性，'m'男性</span><br>    string idNumber; <span class="hljs-comment">//身份证号码</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string, <span class="hljs-type">int</span>, <span class="hljs-type">char</span>, string);<br>    <span class="hljs-built_in">Person</span>(Person&amp;);<br>    ~<span class="hljs-built_in">Person</span>();<br>    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 函数声明</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 函数声明</span><br>};<br><br><span class="hljs-comment">// 成员函数在类体外实现</span><br>Person::<span class="hljs-built_in">Person</span>(string theName, <span class="hljs-type">int</span> theAge, <span class="hljs-type">char</span> theGender, string theIdNumber) {<br>    name = theName;<br>    age = theAge;<br>    gender = theGender;<br>    idNumber = theIdNumber;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">" Constructor called."</span> &lt;&lt; endl;<br>}<br><br>Person::<span class="hljs-built_in">Person</span>(Person&amp; theObject) {<br>    name = theObject.name;<br>    age = theObject.age;<br>    gender = theObject.gender;<br>    idNumber = theObject.idNumber;<br>    cout &lt;&lt; <span class="hljs-string">"Copy Constructor called."</span> &lt;&lt; endl; <span class="hljs-comment">//输出有关信息</span><br>}<br><br>Person::~<span class="hljs-built_in">Person</span>() { <span class="hljs-comment">//析构函数</span><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">" Destructor called."</span> &lt;&lt; endl;<br>}<br><br><span class="hljs-function">string <span class="hljs-title">Person::getName</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> name;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::showInfo</span><span class="hljs-params">()</span> </span>{<br>    cout &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">"age: "</span> &lt;&lt; age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">"gender: "</span> &lt;&lt; gender &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">"id number: "</span> &lt;&lt; idNumber &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"张三"</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'m'</span>, <span class="hljs-string">"12345200006061111"</span>)</span></span>; <span class="hljs-comment">//建立对象p1</span><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">"李四"</span>, <span class="hljs-number">31</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">"12345198111091234"</span>)</span></span>; <span class="hljs-comment">//建立对象p2</span><br><br>    p<span class="hljs-number">1.</span><span class="hljs-built_in">showInfo</span>();<br>    p<span class="hljs-number">2.</span><span class="hljs-built_in">showInfo</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs delphi">张三 <span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">called</span>.</span><br><span class="hljs-function">李四 <span class="hljs-title">Constructor</span> <span class="hljs-title">called</span>.</span><br><span class="hljs-function"><span class="hljs-title">name</span>:</span> 张三<br>age: <span class="hljs-number">12</span><br>gender: m<br>id number: <span class="hljs-number">12345200006061111</span><br><span class="hljs-keyword">name</span>: 李四<br>age: <span class="hljs-number">31</span><br>gender: f<br>id number: <span class="hljs-number">12345198111091234</span><br>李四 <span class="hljs-function"><span class="hljs-keyword">Destructor</span> <span class="hljs-title">called</span>.</span><br><span class="hljs-function">张三 <span class="hljs-title">Destructor</span> <span class="hljs-title">called</span>.</span><br></code></pre></td></tr></tbody></table></figure><p><strong>注意观察输出：构造函数和析构函数调用的顺序！</strong></p><div class="note note-warning">            <ol><li>析构函数在对象作为函数值返回之后被调用。</li></ol>          </div><h2 id="构造函数和析构函数调用顺序">构造函数和析构函数调用顺序</h2><p>一般而言，调用构造函数的次序与调用析构函数的<strong>次序相反</strong>，与栈类似：<strong>先调用构造函数的对象，最后调用析构函数</strong>。</p><h3 id="特殊情况：">特殊情况：</h3><div class="note note-warning">            <ol><li><strong>全局定义</strong>对象（函数体外定义的对象）：程序开始之前调用构造函数，程序结束或调用exit()函数时调用析构函数。</li><li><strong>局部定义</strong>的对象（函数体内定义的对象）：程序执行到定义对象的地方时调用构造函数，函数结束时调用析构函数。</li><li><strong>static定义</strong>的对象：在首次到达对象定义位置时调用构造函数，程序结束时调用析构函数。</li><li><strong>new动态生成</strong>的对象：产生对象时调用构造函数，用delete释放对象时，才调用析构函数。若不使用delete运算符来撤销动态生成的对象，则析构函数不会被调用。</li></ol>          </div><h2 id="对象的动态建立和释放">对象的动态建立和释放</h2><ul><li>new运算符建立对象：<strong>先为类的对象分配内存空间</strong>，然后<strong>自动调用构造函数初始化</strong>对象的数据成员，最后将变量的起始地址返还给指针变量。</li><li>delete运算符释放对象：<strong>只有在delete运算符释放对象时，才会调用析构函数将对象销毁</strong>。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一个复数类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：初始化实部和虚部</span><br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) {<br>        real = r;    <span class="hljs-comment">// 设置实部值</span><br>        imag = i;    <span class="hljs-comment">// 设置虚部值</span><br>        cout &lt;&lt; <span class="hljs-string">"构造函数被调用"</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-comment">// 析构函数：对象销毁时自动调用</span><br>    ~<span class="hljs-built_in">Complex</span>() {<br>        cout &lt;&lt; <span class="hljs-string">"析构函数被调用"</span> &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-comment">// 显示复数的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>{<br>        cout &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; real &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; imag &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; endl;<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;  <span class="hljs-comment">// 复数的实部</span><br>    <span class="hljs-type">double</span> imag;  <span class="hljs-comment">// 复数的虚部</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 动态创建一个Complex对象</span><br>    Complex* pc1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// 调用display方法显示复数</span><br>    pc1-&gt;<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 等价于 (*pc1).display();</span><br><br>    <span class="hljs-comment">// 释放对象内存</span><br>    <span class="hljs-keyword">delete</span> pc1;<br><br>    cout &lt;&lt; <span class="hljs-string">"程序结束"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">构造函数被调用<br>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>析构函数被调用<br>程序结束<br></code></pre></td></tr></tbody></table></figure><h2 id="静态成员">静态成员</h2><p>声明为static的类成员称为静态成员，可以<strong>被类的所有对象共享</strong>。</p><ul><li>静态数据成员：描述这一类对象所共有的数据，所有对象公用这一部分存储空间。</li><li>静态数据函数</li></ul><p>eg:Profit和 static double getProfit() ，总利润是出售所有商品获得的，并不隶属于哪一个商品对象。</p><h3 id="为什么不使用全局变量？">为什么不使用全局变量？</h3><div class="note note-warning">            <ol><li><strong>违背了OOP封装性的精神</strong>，任何地方都可以对全局变量进行访问，破坏了信息隐藏原则</li><li>过多使用全局变量会产生<strong>重名冲突</strong></li><li>能够<strong>明确归属</strong>，直接表明它是类的一部分，便于进行初始化</li></ol>          </div><h3 id="静态数据成员">静态数据成员</h3><p>在类的定义中的数据成员声明前加上关键字<code>static</code>，表示该成员是静态数据成员。由于静态数据成员<strong>由类的所有对象共享</strong>，所以静态成员的存储空间<strong>不会随着对象的产生而分配</strong>，也<strong>不会随着对象的消失而释放</strong>，因此静态数据成员不能在类体内进行初始化，而只能在<strong>类体内进行声明</strong>，在<strong>类体外进行初始化</strong>。</p><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">数据类型名类名::</span>静态数据成员名=初值<span class="hljs-comment">;</span><br></code></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：</p><ul><li><strong>不需要加<code>static</code>关键字</strong></li><li><strong>需要通过作用域运算符<code>::</code>限定修饰</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cgoods</span>{ <br>    <span class="hljs-keyword">private</span>:<br>    ......<br>    <span class="hljs-type">static</span> <span class="hljs-type">double</span> Profit;<br>    <span class="hljs-keyword">public</span>:<br>    ......<br>}<br><span class="hljs-type">double</span> cgoods::Profit=<span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure><p>类外的定义是必要的，若没有明确赋初值，则编译系统会自动赋初值为0。</p><h3 id="静态成员函数">静态成员函数</h3><p>与类的数据成员相同，在成员函数前加上<code>static</code>可以创建一个静态成员函数。静态函数没有<code>this</code>指针，通常他只访问属于全体对象的成员————即静态成员。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cgoods::getProfit</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">return</span> Profit;<span class="hljs-comment">//使用了静态成员变量</span><br>}<br></code></pre></td></tr></tbody></table></figure><div class="note note-warning">            <ol><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员</li><li>静态成员函数不能直接访问非静态成员函数和非静态数据成员</li></ol>          </div><h3 id="静态成员的访问">静态成员的访问</h3><p>用类的对象访问 || 直接用作用域运算符“::”通过类名访问</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">类名::静态数据成员名<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">对象名.静态数据成员名<br><span class="hljs-comment">//容易让人误认为静态数据成员是属于某个对象的</span><br></code></pre></td></tr></tbody></table></figure><p>静态成员函数的访问与静态成员数据的访问的形式相同，不做过多阐释。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStudent</span> {<br><span class="hljs-keyword">private</span>:<br>    string SName;       <span class="hljs-comment">// 保存学生姓名</span><br>    <span class="hljs-type">float</span> Score;        <span class="hljs-comment">// 保存学生的成绩</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> studentTotal;    <span class="hljs-comment">// 静态数据成员，保存学生的总人数</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">float</span> SumScore;      <span class="hljs-comment">// 静态数据成员，保存所有学生的成绩和</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，当新建一个对象时，人数studentTotal加1</span><br>    <span class="hljs-built_in">CStudent</span>(string name, <span class="hljs-type">float</span> sc);<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">float</span> <span class="hljs-title">average</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 计算学生的平均分</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// 打印输出学生的姓名和分数</span><br>    ~<span class="hljs-built_in">CStudent</span>();                <span class="hljs-comment">// 析构函数，当减少一个对象时，studentTotal减1</span><br>};<br><br><span class="hljs-comment">// 静态数据成员的初始化必须在类外进行</span><br><span class="hljs-type">int</span> CStudent::studentTotal = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> CStudent::SumScore = <span class="hljs-number">0</span>;<br><br>CStudent::<span class="hljs-built_in">CStudent</span>(string name, <span class="hljs-type">float</span> sc) {<br>    SName = name;<br>    Score = sc;<br>    studentTotal++;     <span class="hljs-comment">// 学生人数加1</span><br>    SumScore += sc;     <span class="hljs-comment">// 总分数增加</span><br>    cout &lt;&lt; SName &lt;&lt; <span class="hljs-string">" Constructor called."</span> &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CStudent::Print</span><span class="hljs-params">()</span> </span>{<br>    cout &lt;&lt; SName &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; Score &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CStudent::average</span><span class="hljs-params">()</span> </span>{     <span class="hljs-comment">// 静态成员函数访问静态数据成员</span><br>    <span class="hljs-keyword">if</span> (studentTotal == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 防止除以0</span><br>    <span class="hljs-keyword">return</span> (SumScore / studentTotal);<br>}<br><br>CStudent::~<span class="hljs-built_in">CStudent</span>() {<br>    studentTotal--;     <span class="hljs-comment">// 学生人数减1</span><br>    SumScore -= Score;  <span class="hljs-comment">// 总分数减少</span><br>    cout &lt;&lt; SName &lt;&lt; <span class="hljs-string">" Destructor called."</span> &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 简单测试</span><br>    <span class="hljs-function">CStudent <span class="hljs-title">stud1</span><span class="hljs-params">(<span class="hljs-string">"Zhang San"</span>, <span class="hljs-number">90</span>)</span></span>;<br>    <span class="hljs-function">CStudent <span class="hljs-title">stud2</span><span class="hljs-params">(<span class="hljs-string">"Li Si"</span>, <span class="hljs-number">80</span>)</span></span>;<br>    stud<span class="hljs-number">1.</span><span class="hljs-built_in">Print</span>();<br>    stud<span class="hljs-number">2.</span><span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">"平均分为: "</span> &lt;&lt; CStudent::<span class="hljs-built_in">average</span>() &lt;&lt; endl;  <span class="hljs-comment">// 调用静态成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Zhang San <span class="hljs-function"><span class="hljs-keyword">Constructor</span> <span class="hljs-title">called</span>.</span><br><span class="hljs-function"><span class="hljs-title">Li</span> <span class="hljs-title">Si</span> <span class="hljs-title">Constructor</span> <span class="hljs-title">called</span>.</span><br><span class="hljs-function"><span class="hljs-title">Zhang</span> <span class="hljs-title">San</span>:</span> <span class="hljs-number">90</span><br>Li Si: <span class="hljs-number">80</span><br>平均分为: <span class="hljs-number">85</span><br>Li Si <span class="hljs-function"><span class="hljs-keyword">Destructor</span> <span class="hljs-title">called</span>.</span><br><span class="hljs-function"><span class="hljs-title">Zhang</span> <span class="hljs-title">San</span> <span class="hljs-title">Destructor</span> <span class="hljs-title">called</span>.</span><br></code></pre></td></tr></tbody></table></figure><h2 id="this指针">this指针</h2><ul><li>用途：当成员函数的<strong>参数名与成员变量名相同</strong>的时候，可以使用<code>this</code>来<strong>明确地引用成员变量</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Ponit&amp; <span class="hljs-title">setPoint</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{<br>    <span class="hljs-keyword">this</span>-&gt;x=x;<br>    (*<span class="hljs-keyword">this</span>).y=y<span class="hljs-number">+8</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><div class="note note-warning">            <ol><li>this指针是一个<strong>指向对象的指针</strong></li><li>this指针是一个隐含于成员函数中的对象指针</li><li>this指针是一个指向正在调用成员函数的对象的指针</li><li><strong>类的静态成员函数没有this指针</strong></li></ol>          </div><h2 id="常对象">常对象</h2><p>常对象用<code>const</code>进行修饰，常对象必须进行初始化，且不能被更新，常对象的声明如下（两种声明完全相同，没有任何区别）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> 类名 对象名[(实参列表)]；<br>类名 <span class="hljs-type">const</span> 对象名[(实参列表)]；<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> Point <span class="hljs-title">P1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function">Point <span class="hljs-type">const</span> <span class="hljs-title">P2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>以上定义了两个常对象P1、P2。在任何场合，对象P1、P2中的成员值不能进行修改。<br>常对象不能调用非const成员函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{<span class="hljs-comment">//常成员函数</span><br>    <span class="hljs-keyword">return</span> x*y;<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果一定要修改常对象中的数据成员，可将需要修改的数据成员声明为<code>mutable</code>，这样就可以用声明为<code>const</code>的成员函数来修改它的值了！</p><h2 id="友元类">友元类</h2><p>若我们想要一个不属于某个类的函数存取该类中的数据：</p><ol><li>将类中的数据成员均设置为<code>public</code></li><li><strong>在类内部声明</strong>这个函数为友元（friend），则这个函数可以访问该类的私有成员</li></ol><p>第一点有违OOP封装性的精神，显然第二种更好！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br><span class="hljs-keyword">private</span>: <br>    string name;  <br>    <span class="hljs-type">int</span> age;      <br>    <span class="hljs-type">char</span> gender;  <br>    string idNumber; <br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string, <span class="hljs-type">int</span>, <span class="hljs-type">char</span>, string);<br>    <span class="hljs-built_in">Person</span>(Person&amp;);<br>    ~<span class="hljs-built_in">Person</span>() {}<br>    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 函数声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">(Person&amp; p)</span></span>;  <span class="hljs-comment">// 声明showInfo为类Person的友元函数</span><br>};<br><br>Person::<span class="hljs-built_in">Person</span>(string theName, <span class="hljs-type">int</span> theAge, <span class="hljs-type">char</span> theGender, string theIdNumber) {  <br>    name = theName;<br>    age = theAge;<br>    gender = theGender;<br>    idNumber = theIdNumber;  <br>}<br><br>Person::<span class="hljs-built_in">Person</span>(Person&amp; theObject) {<br>    name = theObject.name;<br>    age = theObject.age;  <br>    gender = theObject.gender;  <br>    idNumber = theObject.idNumber;  <br>}<br><br><span class="hljs-function">string <span class="hljs-title">Person::getName</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> name;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">(Person&amp; p)</span> </span>{  <span class="hljs-comment">// showInfo为普通函数，是类Person的友元函数</span><br>    cout &lt;&lt; <span class="hljs-string">"name: "</span> &lt;&lt; p.name &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">"age: "</span> &lt;&lt; p.age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">"gender: "</span> &lt;&lt; p.gender &lt;&lt; endl;  <br>    cout &lt;&lt; <span class="hljs-string">"id number: "</span> &lt;&lt; p.idNumber &lt;&lt; endl; <br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"张三"</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'m'</span>, <span class="hljs-string">"12345200006061111"</span>)</span></span>;  <span class="hljs-comment">// 建立对象p1</span><br>    <span class="hljs-built_in">showInfo</span>(p1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">name: 张三<br>age: <span class="hljs-number">12</span><br>gender: m<br>id number: <span class="hljs-number">12345200006061111</span><br></code></pre></td></tr></tbody></table></figure><h4 id="注意：">注意：</h4><div class="note note-warning">            <ul><li>友元函数是类外函数，友元函数不能直接访问类中的私有和保护成员，而<strong>需要通过对象参数进行访问</strong></li></ul>          </div><p>这个案例显然并没有那么好，我们可以将<code>showInfo</code>函数设计为类内一个普通的成员函数，这没有显示出友元函数的必要性，仅仅是对友元函数用法的一个初步介绍！</p><h3 id="友元函数是另一个类的成员函数">友元函数是另一个类的成员函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cuboid</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Height;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> h) : <span class="hljs-built_in">Height</span>(h) {}  <span class="hljs-comment">// 使用初始化列表</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Volume</span><span class="hljs-params">(Rectangle&amp; r)</span></span>;     <span class="hljs-comment">// 只能声明，不能定义（因为Rectangle未完全定义）</span><br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Width, Length;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len) : <span class="hljs-built_in">Width</span>(w), <span class="hljs-built_in">Length</span>(len) {}  <span class="hljs-comment">// 初始化列表</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">Cuboid::Volume</span><span class="hljs-params">(Rectangle&amp; r)</span></span>;  <span class="hljs-comment">// 声明友元函数</span><br>};<br><br><span class="hljs-comment">// 必须在 Rectangle 定义之后才能定义 Volume</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cuboid::Volume</span><span class="hljs-params">(Rectangle&amp; r)</span> </span>{<br>    <span class="hljs-keyword">return</span> r.Length * r.Width * Height;  <span class="hljs-comment">// 访问 Rectangle 的私有成员</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">Rectangle <span class="hljs-title">R</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>)</span></span>;<br>    <span class="hljs-function">Cuboid <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">"长方体的体积为："</span> &lt;&lt; C.<span class="hljs-built_in">Volume</span>(R) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">长方体的体积为：960<br></code></pre></td></tr></tbody></table></figure><p>这里将类<code>Cuboid</code>的成员函数<code>Volume()</code>声明为类<code>Rectangle</code>的友元函数，这样在<code>Volume()</code>中就可以使用Rectangle中的私有数据成员<code>Width</code>、<code>Length</code>。</p><h4 id="注释：">注释：</h4><div class="note note-warning">            <p>程序第三行对<code>Rectangle</code>的<strong>提前声明引用</strong>，只包含类名，不包含类体。提前声明的原因是：在类<code>Cuboid</code>中调用<code>Volume()</code>函数时，需要使用类<code>Rectangle</code>中的数据成员<code>Length</code>和<code>Width</code>，但是类<code>Rectangle</code>还没有定义。那如果将<code>Rectangle</code>的定义提到前面呢？同样是不可以的，因为在类<code>Rectangle</code>中又包含了<code>Cuboid</code>的成员！但是不能因为提前声明，而去定义一个对象！</p>          </div><p>例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>;<span class="hljs-comment">//提前引用声明</span><br>Rectangle r1;<span class="hljs-comment">//紧接着定义一个Rectangle对象，这是不允许的！</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>{...};<br></code></pre></td></tr></tbody></table></figure><h3 id="友元类-v2">友元类</h3><p>将一个类声明为另一个类的友元：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br>    ...<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<span class="hljs-comment">//类B声明为当前类A的友元类</span><br>    ...<br>};<br></code></pre></td></tr></tbody></table></figure><p>此时，类B中的所有成员函数都是当前类A的友元函数，因此类B中的<strong>所有成员函数</strong>都可以访问当前类A的<code>private</code>成员或<code>protected</code>成员</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cuboid</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Height;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cuboid</span>(<span class="hljs-type">int</span> h) {<br>        Height = h;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Volume</span><span class="hljs-params">(Rectangle&amp; r)</span></span>;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Width, Length;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> len) {<br>        Width = w;<br>        Length = len;  <span class="hljs-comment">// 添加了分号</span><br>    }<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cuboid</span>; <span class="hljs-comment">// 声明类Cuboid是类Rectangle的友元类</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Cuboid::Volume</span><span class="hljs-params">(Rectangle&amp; r)</span> </span>{<br>    <span class="hljs-keyword">return</span> r.Length * r.Width * Height;  <span class="hljs-comment">// 正确的体积计算公式</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">Rectangle <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>)</span></span>;<br>    <span class="hljs-function">Cuboid <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">"长方体的体积为："</span> &lt;&lt; C.<span class="hljs-built_in">Volume</span>(r) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">长方体的体积为：960<br></code></pre></td></tr></tbody></table></figure><h3 id="友元关系的限制：">友元关系的限制：</h3><div class="note note-warning">            <ol><li>友元关系<strong>不具有传递性</strong>，“附庸的附庸不是我的附庸”，比如类A是类B的友元类，类B是类C的友元类，类C不是类A的友元类。</li><li>友元关系<strong>不具有交换性</strong>，比如类A是类B的友元类，类B不一定是类A的友元</li><li>友元关系是<strong>不能继承的</strong>，比如类A是类B的友元类，类C继承类B，类C不是类A的友元类</li></ol>          </div><p>封面来源：<a href="https://www.youtube.com/watch?v=m_MQYyJpIjg">Fundamental Concepts of Object Oriented Programming</a></p><h2 id="References">References</h2><p>以上大部分代码均取自《C++程序设计基础教程》</p>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operator Overloading in C++</title>
    <link href="/2025/07/19/CPP/Operator-Overloading-in-C++/"/>
    <url>/2025/07/19/CPP/Operator-Overloading-in-C++/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optimization Algorithm in Mathematical Modeling</title>
    <link href="/2025/07/19/Mathematical%20Modeling%20Tutorial/Optimization-Algorithm-in-Mathematical-Modeling/"/>
    <url>/2025/07/19/Mathematical%20Modeling%20Tutorial/Optimization-Algorithm-in-Mathematical-Modeling/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Mathematical Modeling Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Four Pillars of OOP in C++</title>
    <link href="/2025/07/17/CPP/The-Four-Pillars-of-OOP-in-C++/"/>
    <url>/2025/07/17/CPP/The-Four-Pillars-of-OOP-in-C++/</url>
    
    <content type="html"><![CDATA[<h2 id="抽象性-Abstract">抽象性 (Abstract)</h2><p>提取事物的本质特征，找出共性，忽略非本质特征！</p><ul><li><h3 id="数据抽象">数据抽象</h3></li></ul><p>抽象出对象的属性和状态的描述。（变量）</p><ul><li><h3 id="行为抽象">行为抽象</h3></li></ul><p>抽象出对象行为的描述。（成员函数）</p><h2 id="封装性-Encapsulation">封装性 (Encapsulation)</h2><ol><li><p>设计者将对象的全部属性和行为封装在对象内部，对象的属性值（变量）只能由这个对象的行为（成员函数）来读取和修改！</p></li><li><p>使用者无需关心内部结构，只需关心能做什么、如何使用！</p></li></ol><h3 id="成员函数的定义：">成员函数的定义：</h3><ul><li><p>关键词<code>private</code>、<code>protected</code>、<code>public</code>在类中使用的先后次序无关紧要，且<strong>可以多次使用</strong>。</p></li><li><p>因为类是一种数据类型，系统<strong>不会为其分配内存空间</strong>，所以在定义类中的数据成员时，不能对其进行初始化，也不能指定其存储类型。对于类内<strong>非static数据成员的初始化</strong>通常<strong>使用构造函数</strong>进行。</p></li></ul><ol><li>在<strong>类内</strong>定义成员函数</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cgoods</span>{<span class="hljs-comment">//商品类</span><br>     <br>     <span class="hljs-keyword">private</span>:<br>        string ID; <span class="hljs-comment">//商品编号</span><br>        string name; <span class="hljs-comment">//商品名称</span><br>        <span class="hljs-type">double</span> Purchasingprice; <span class="hljs-comment">//进货价格</span><br>        <span class="hljs-type">double</span> Sellingprice; <span class="hljs-comment">//售出价格</span><br>        <span class="hljs-type">int</span> SellCount; <span class="hljs-comment">//售出数量</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">double</span> Profit; <span class="hljs-comment">//总利润</span><br>     <br>     <span class="hljs-keyword">protected</span>:<span class="hljs-comment">//无</span><br>     <br>     <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">cgoods</span>(string id, string name, <span class="hljs-type">double</span> purchasingprice){<span class="hljs-comment">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        }<br><br>        <span class="hljs-built_in">cgoods</span>(string id, string name, <span class="hljs-type">double</span> purchasingprice){<span class="hljs-comment">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        Purchasingprice=purchasingprice;<br>        }<br><br>        ~<span class="hljs-built_in">cgoods</span>(){<span class="hljs-comment">//析构函数</span><br>        } <br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetPurchasingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> purchasingprice)</span></span>{<span class="hljs-comment">//设置进货价格</span><br>        Purchasingprice=purchasingprice;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetSellingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> sellingprice)</span></span>{<span class="hljs-comment">//设置出货价格</span><br>        Sellingprice=sellingprice;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>{<br>        cout&lt;&lt;<span class="hljs-string">"编号"</span>&lt;&lt;ID&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">"名称"</span>&lt;&lt;Name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">"进货价格"</span>&lt;&lt;Purchasingprice&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">"出货价格"</span>&lt;&lt;Sellingprice&lt;&lt;endl;<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>在<strong>类外</strong>定义成员函数</li></ol><p>成员函数<strong>在类体内进行声明</strong>，而将成员函数的<strong>定义放在类外</strong>，相比于类内定义成员函数，成员函数名前要多<strong>加上“类名::”</strong>,“::”是作用于运算符，以说明这个函数是属于那类的成员函数，否则编译器就会认为该函数是一个普通函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">返回类型 类名::成员函数名(参数说明){<br>     函数体<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cgoods</span>{<span class="hljs-comment">//商品类</span><br>     <br>     <span class="hljs-keyword">private</span>:<br>        string ID; <span class="hljs-comment">//商品编号</span><br>        string name; <span class="hljs-comment">//商品名称</span><br>        <span class="hljs-type">double</span> Purchasingprice; <span class="hljs-comment">//进货价格</span><br>        <span class="hljs-type">double</span> Sellingprice; <span class="hljs-comment">//售出价格</span><br>        <span class="hljs-type">int</span> SellCount; <span class="hljs-comment">//售出数量</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">double</span> Profit; <span class="hljs-comment">//总利润</span><br>     <br>     <span class="hljs-keyword">protected</span>:<span class="hljs-comment">//无</span><br>     <br>     <span class="hljs-keyword">public</span>:<br>        <br>        <span class="hljs-built_in">cgoods</span>(string id, string name, <span class="hljs-type">double</span> purchasingprice);<span class="hljs-comment">//构造函数</span><br>        <br>        <span class="hljs-built_in">cgoods</span>(string id, string name, <span class="hljs-type">double</span> purchasingprice);<span class="hljs-comment">//构造函数</span><br>        <br>        ~<span class="hljs-built_in">cgoods</span>();<span class="hljs-comment">//析构函数</span><br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetPurchasingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> purchasingprice)</span></span>;<span class="hljs-comment">//设置进货价格</span><br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetSellingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> sellingprice)</span></span>;<span class="hljs-comment">//设置出货价格</span><br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//显示商品信息</span><br>}<br><br>        cgoods::<span class="hljs-built_in">cgoods</span>(string id, string name){<span class="hljs-comment">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        }<br><br>        cgoods::<span class="hljs-built_in">cgoods</span>(string id, string name, <span class="hljs-type">double</span> purchasingprice){<span class="hljs-comment">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        Purchasingprice=purchasingprice;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cgoods::SetPurchasingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> purchasingprice)</span></span>{<span class="hljs-comment">//设置进货价格</span><br>        Purchasingprice=purchasingprice;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cgoods::SetSellingprice</span><span class="hljs-params">(<span class="hljs-type">double</span> sellingprice)</span></span>{<span class="hljs-comment">//设置出货价格</span><br>        Sellingprice=sellingprice;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cgoods::display</span><span class="hljs-params">()</span></span>{<span class="hljs-comment">//显示商品信息</span><br>        cout&lt;&lt;<span class="hljs-string">"编号"</span>&lt;&lt;ID&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">"名称"</span>&lt;&lt;Name&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">"进货价格"</span>&lt;&lt;Purchasingprice&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">"出货价格"</span>&lt;&lt;Sellingprice&lt;&lt;endl;<br>        }<br></code></pre></td></tr></tbody></table></figure><h2 id="继承性-Inherit">继承性 (Inherit)</h2><p>派生类既能有自己新定义的属性和行为，又能够继承父类的所有属性和行为，无需重复定义，这种允许和鼓励类的重用的继承设计对于提高软件开发效率有着重要意义！</p><h2 id="多态性-Polymorphism">多态性 (Polymorphism)</h2><p>多态性使得可以通过相同的调用方式来调用这些具有不同功能的同名函数，这样同一个属性在父类和派生类中具有不同的语义！</p>]]></content>
    
    
    <categories>
      
      <category>CPP</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Life-musings</title>
    <link href="/2025/07/14/other/life-musings/"/>
    <url>/2025/07/14/other/life-musings/</url>
    
    <content type="html"><![CDATA[<h1>Life-musings</h1><p><strong>生活随想录~</strong></p><hr><p>记录生活中一点小事！<br>保持更新的节奏！</p><h2 id="2025-7-14">2025.7.14</h2><p>搬宿舍忙一上午，累瘫了！<br>来到睢宁支教了，教学楼相当 Modern！<br><strong>cool！</strong></p><h2 id="2025-7-16">2025.7.16</h2><p>Turtle in Python 大win特win！</p><h2 id="2025-7-17">2025.7.17</h2><p>昨晚备课到两点…<br>逐渐适应老师的身份！<br>制作课件的过程中也顺便二次学习Python语法！</p><h2 id="2025-7-18">2025.7.18</h2><p>成功给 blog 添加 category 功能！</p><h2 id="2025-7-22">2025.7.22</h2><p>上知网阅读相关论文，<strong>着手准备26大创pre</strong>！<br>在roboflow上找到几个感觉适配的<strong>数据集</strong>！<br>但是还是感觉有些缺失，需要自己想办法解决…</p><h2 id="2025-7-23">2025.7.23</h2><p>参考数据结构教材，重新梳理了几种常见的<strong>排序算法的核心思路</strong>！<br>自己敲了敲各种排序算法的代码，interesting！</p><h2 id="2025-7-24">2025.7.24</h2><p>试图给博客添加vercel进行<strong>自动化部署</strong>，<br>似乎不是很成功 😢</p><h2 id="2025-7-25">2025.7.25</h2><p>听了UC Berkeley的CS61A 感觉US的CS课程比国内超前太多了！<br>图文并茂、简洁利索、一目了然的！<br>他们注重编程思想的培养，和项目实战，在实践中感受编程的魅力！<br>而我们的老师总是长篇累牍的教授语法知识，煞是枯燥无味！</p><h2 id="2025-7-26">2025.7.26</h2><p>The Missing Semester of Your CS Education！<br><code>shell</code>篇，受益匪浅！</p><h2 id="2025-7-27">2025.7.27</h2><p>先是赛车，再是足球！忙活一天！<br>回来总算是吧<code>shell</code>篇的博客写完了！<br>还顺带配置了博客 emoji 😄<br>以后终于不再是文文并茂了😢</p><h2 id="2025-7-28">2025.7.28</h2><p>继续[missing semster]，学完了<code>vim</code>篇！</p><h2 id="2025-7-29">2025.7.29</h2><p>完善<code>Git</code>篇！<br>捣鼓我的 mac！</p><h2 id="2025-7-30">2025.7.30</h2><p>终于在 macbook 上成功配置博客环境！<br>单人多设备假装自己是多人协作开发大项目😄</p><h2 id="2025-7-31">2025.7.31</h2><p>mac 中尝试在<code>vim</code>写、编译运行<code>c++</code>！<br><strong>skilled programmer</strong> 既视感😄</p><h2 id="2025-8-1">2025.8.1</h2><p>入门<strong>dynamic programming</strong>！<br>祝好运😉</p><h2 id="2025-8-6">2025.8.6</h2><p>归来！准备数学建模！</p><h2 id="2025-8-7">2025.8.7</h2><p><strong>LaTex</strong>简单入门，优雅，太优雅了！😊<br>果然学习才是<strong>祛魅</strong>的最好方式！<br><strong>overleaf</strong>在线共享编辑，真是个好东西！😄</p><h2 id="2025-8-8">2025.8.8</h2><p>LaTex 太灾难了😢<br>还是更喜欢<strong>WYSWYG</strong>😊</p><h2 id="2025-8-9">2025.8.9</h2><p>LaTex 还得是在实战中学习！</p><p>但感觉花大量时间学习性价比不太高😢<br>AI辅助 LaTex就很舒服😀</p><h2 id="2025-8-10">2025.8.10</h2><p>终于整完了，呼~~<br>要投身算法学习哩！<br>不能再依靠 life-musings 栏目苟延残喘更新速度了😡</p><h2 id="2025-8-11">2025.8.11</h2><p>summer vacation assignment😡</p><h2 id="2025-8-12">2025.8.12</h2><p>full stack 颇有感触！<br>在AI高速发展的当下，我们计算机专业的学习也应该与时俱进，从前我总是习惯于看书学习，从最基础的点开始将知识吸收，往往还没做出什么成果，学习的热情就被消耗殆尽，感叹一句“真难啊”！但是现在有了AI的帮助，我们的学习或许可以不那么注重细节，可以自顶向下的，得“意”忘“形”的，我们只需先了解其大致框架、工作原理，再利用AI在框架中缝缝补补，哪里有问题去学哪里，这样不仅可以短时间内做出一定成果提升成就感，同时也避免的花费大量时间摄入无用或极少使用的知识！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Simple Git Project Management Guide</title>
    <link href="/2025/07/13/Tutorial/Simple-Git-Project-Management-Guide/"/>
    <url>/2025/07/13/Tutorial/Simple-Git-Project-Management-Guide/</url>
    
    <content type="html"><![CDATA[<p><strong>本文简单介绍了使用Git进行项目管理的操作。</strong></p> <span id="more"></span><p><code>Git</code> 是一个分布式版本控制系统(<code>Vision Control Systems</code>)，它允许多个人在同一项目上工作。通过<code> Git</code>，我们可以记录项目的每一次更改，并且可以将代码推送到 <code>GitHub</code>，方便以后查看和分享（多人的协作开发）。以下是<code>Git</code>进行代码版本管理的基本操作：</p><h2 id="基本操作">基本操作</h2><h3 id="1、在本地初始化git仓库">1、在本地初始化git仓库</h3><p>打开命令行工具（<code>Windows</code> 用户可以使用 <code>PowerShell</code>，<code>Mac</code> 和 <code>Linux</code> 用户可以使用终端），确保你进入了项目文件夹（命令：<code>cd path</code>），然后输入以下命令来初始化 <code>Git</code> 仓库：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></tbody></table></figure><p><strong>解释：</strong><code>git init</code>会在当前文件夹中创建一个新的 Git 仓库。现在，你的项目文件夹已经开始被 Git 追踪，之后的每一次文件修改都可以通过 Git 来记录。</p><h3 id="2、添加文件到暂存区">2、添加文件到暂存区</h3><p>暂存区是一个准备提交的区域，只有在将文件添加到暂存区后，才能将它们提交到本地仓库中。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add<br></code></pre></td></tr></tbody></table></figure><p><strong>解释</strong>:<code>git add.</code>会将当前文件夹下的所有文件添加到暂存区。这意味着 Git 现在知道这些文件已经被修改，并准备将它们保存到版本历史中。</p><h3 id="3、提交文件到本地仓库">3、提交文件到本地仓库</h3><p>暂存区中的文件提交到本地仓库。输入以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">"feat: "</span><br></code></pre></td></tr></tbody></table></figure><p><strong>解释：</strong><code>git commit -m</code> 命令用于提交更改到本地仓库，并且 <code>-m</code> 参数后面跟着的是你为此次提交添加的描述信息，也就是提交信息（<code>commit message</code>）。提交信息是对此次提交所做更改的简短描述，它帮助团队成员或其他查看项目历史的人理解每次提交的目的或内容。</p><p>这些是特定的标签或标识符来说明提交的类型：</p><ul><li><code>feat</code>: 表示新功能的增加（<code>feature</code>）</li><li><code>fix</code>: 表示修复了一个<code>bug</code></li><li><code>docs</code>: 表示文档更新</li><li><code>refactor</code>: 表示代码重构（既不是修复bug也不是添加新功能）</li><li><code>style</code>: 改进代码格式但不影响逻辑</li><li><code>test</code>: 添加或修正测试用例</li></ul><h3 id="4-创建远程仓库">4. 创建远程仓库</h3><p>前往 <code>GitHub</code>，创建一个新的远程仓库，并命名，注意：不要勾选“初始化仓库”，因为我们已经在本地初始化了仓库。</p><h3 id="5-关联本地仓库">5. 关联本地仓库</h3><p>在命令行中，输入以下命令来将本地仓库和 GitHub 的远程仓库关联起来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote set-url origin https://令牌@github.com/用户名/远程仓库名`<br></code></pre></td></tr></tbody></table></figure><h3 id="6、推送代码到-GitHub">6、推送代码到 GitHub</h3><p>最后一步，我们将本地仓库中的更改推送到 <code>GitHub</code> 上的远程仓库：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin main<br></code></pre></td></tr></tbody></table></figure><p><strong>解释：</strong><code>git push</code> 命令会将本地仓库中的代码上传到 <code>GitHub</code> 的远程仓库。<code>-u</code> 参数会将本地的 <code>main</code> 分支与远程仓库的 <code>main</code> 分支关联起来，确保以后每次推送都不需要重复指定分支。</p><h2 id="底层实现">底层实现</h2><p><code>VCS</code> 通过一系列快照跟踪文件夹及其内容的更改，其中每个快照都封装了顶级目录中文件/文件夹的完整状态，其还维护元数据，例如每个快照的创建者、与每个快照相关的消息等等。</p><h3 id="快照">快照</h3><p><code>Git</code> 将某个顶级目录中文件和文件夹集合的历史记录建模为一系列快照。文件/文件夹的树模型：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;root&gt; (tree)<br>|<br>+- foo (tree)<br>|  |<br>|  + bar.txt (blob, contents = <span class="hljs-string">"hello world"</span>)<br>|<br>+- baz.txt (blob, contents = <span class="hljs-string">"git is wonderful"</span>)<br></code></pre></td></tr></tbody></table></figure><h3 id="关联快照">关联快照</h3><div class="note note-warning">            <p>不知你是否有过疑惑。如果我和我的伙伴并行共同完成一个项目的两个特性应该如何处理？是将他的那部分完成后让我在复制到我的版本上吗？显然那样做太过麻烦！</p>          </div><p>在<code>Git</code>中，历史记录是快照的<strong>有向无环图</strong> (<code>DAG</code>)。这意味着<code>Git </code>中的每个快照都指向一组“父级”，即它之前的快照。它是一组父级，而不是单个父级（线性历史记录中的情况），因为快照可能源自多个父级，例如，由于合并（合并）两个并行的开发分支。<code>Git</code> 将这些快照称为“提交”。可视化提交历史记录可能如下所示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">o &lt;-- o &lt;-- o &lt;-- o<br>            ^<br>             \<br>              --- o &lt;-- o<br></code></pre></td></tr></tbody></table></figure><p><code> o</code>s代表单个提交（快照），理解为提交的文件（夹）</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o<br>           ^            /<br>            \          v<br>             --- o &lt;-- o<br></code></pre></td></tr></tbody></table></figure><p>这里意味着并行开发项目的两个功能，并进行合并，创建了一个包含两个功能的快照，<code>Git</code>会自行合并处理两个快照，若出现冲突无法解决时，则需要人工进行调整！</p><div class="note note-warning">            <p>如果我上线测试时突然发现了一个<code>bug</code>，而我不知道他是他是何时产生的应该怎么办呢？</p>          </div><p><code>Git</code>也会提供相应的二分历史记录查找！</p><h2 id="总结">总结</h2><p>至此，你学会了如何通过 <code>Git</code> 管理项目的版本历史，最终将项目代码推送到 <code>GitHub</code>。整个过程包括了从初始化仓库、添加文件、提交文件到推送到远程仓库的完整步骤。通过这些操作，你便已经具备了基本的版本控制能力。</p><p>封面来源：<a href="https://www.youtube.com/watch?v=hwP7WQkmECE">Git Explained in 100 Seconds</a></p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo,Unleash Your Blogging Magic</title>
    <link href="/2025/07/12/Tutorial/Hexo-Hacks-Unleash-Your-Blogging-Magic/"/>
    <url>/2025/07/12/Tutorial/Hexo-Hacks-Unleash-Your-Blogging-Magic/</url>
    
    <content type="html"><![CDATA[<p><strong>本文简单介绍了Hexo搭建个人博客的丰富玩法和不同平台撰写博客上的适配差异。</strong></p> <span id="more"></span><h2 id="一、玩转Hexo">一、玩转<code>Hexo</code></h2><p>不同主题的Hexo主题博客，大致特点如下：</p><table><thead><tr><th>主题</th><th>特点</th></tr></thead><tbody><tr><td><strong>Fluid</strong></td><td>加载速度快，有简单的动态效果，移动端适配佳</td></tr><tr><td><strong>Butterfly</strong></td><td>功能全面，社区活跃，高度可定制</td></tr><tr><td><strong>Landscape</strong></td><td>默认主题，轻量级，简洁易上手（有较多限制）</td></tr></tbody></table><p>博主尝试了这几种后对<code>fluid</code>追一见钟情，遂使用此主题。</p><h3 id="（一）更换主题">（一）更换主题</h3><p><strong>1. 安装 <code>Fluid</code> 主题</strong></p><p>在 Hexo 博客根目录（<code>/HexoData</code>）运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></tbody></table></figure><p><strong>2. 修改 <code>Hexo</code> 主配置</strong></p><p>打开<code>_config.yml</code>（位于博客根目录），找到<code>theme</code>字段，修改为：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></tbody></table></figure><p>如需要可以将 <code>language</code> 设置为中文：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></tbody></table></figure><p><strong>3. 创建 Fluid 的配置文件</strong></p><p><code>Fluid</code>主题的配置需要额外文件：<br>在博客根目录下创建<code>_config.fluid.yml</code>文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> node_modules/hexo-theme-fluid/_config.yml _config.fluid.yml<br></code></pre></td></tr></tbody></table></figure><p>编辑<code>_config.fluid.yml</code>来自定义主题（如菜单、颜色、字体等）。</p><p><strong>4. 迁移 Landscape 的内容（可选）</strong></p><p>自定义样式/脚本：将 <code>Landscape</code> 的 <code>source/css</code> 或 <code>source/js</code> 文件复制到 <code>Fluid</code> 的 <code>source</code> 目录。<br>文章/页面：<code>_posts</code> 和<code> _pages</code> 内容无需迁移，<code>Hexo</code> 会自动读取。</p><p><strong>5. 清理并重新生成</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></tbody></table></figure><p>访问 <a href="http://localhost:4000">http://localhost:4000</a> 查看效果。</p><h3 id="（二）添加评论系统">（二）添加评论系统</h3><p><a href="https://blog.csdn.net/Neter_Leon/article/details/107064603?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo%E7%9A%84fulid%E4%B8%8D%E5%90%8C%E7%8E%A9%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107064603.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187">Hexo快速构建个人小站-Fulid主题下添加Valine评论系统(三)</a><br>注意<code>comments</code>在(<code>\themes\你的主题名\_config.yml</code>)文件中，Hexo 主配置文件(<code>_config.yml</code>)通常用于全局配置（如博客标题、作者等），添加评论系统的配置不在这个文件中。将<code>appid</code>和<code>appkey</code>填入，同时记得根据选择的插件修改博客评论系统的<code>type</code>！</p><h3 id="（三）添加背景音乐">（三）添加背景音乐</h3><p><a href="https://blog.csdn.net/weixin_43471926/article/details/109798928?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224db07d60e8ad014b04fcc3b6dc2a5cdf%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=4db07d60e8ad014b04fcc3b6dc2a5cdf&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109798928-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=hexo%20fluid%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90&amp;spm=1018.2226.3001.4187">Hexo-Fluid主题添加音乐页面</a></p><h3 id="（四）给每篇博客添加封面-背景">（四）给每篇博客添加封面/背景</h3><p>在<code>source</code>文件夹下新建<code>medias</code>文件夹用于存放图片，在每篇博客文章<code>front-matter</code>的区域添加：<br><strong>背景图片：</strong></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">banner<span class="hljs-emphasis">_img: 图片路径（/medias/图片文件名）</span><br></code></pre></td></tr></tbody></table></figure><p><strong>封面图片预览：</strong></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">index<span class="hljs-emphasis">_img: 图片路径（/medias/图片文件名）</span><br></code></pre></td></tr></tbody></table></figure><p>其他丰富玩法参考官方文档：</p><ul><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li></ul><h2 id="二、CSDN与Hexo撰写差异">二、CSDN与Hexo撰写差异</h2><p><strong>1. 插入图片</strong><br>插入图片的语法如下：<code>![插入图片的注释](插入图片的连接或本地路径)</code><br>  CSDN 不支持本地图片链接：如果你在 CSDN 写博客时插入本地图片路径，其他用户无法访问你的本地文件。<br>  使用Hexo进行博客撰写时，图片可以放在<code>source/images/ 文件夹（可以自行创建）</code>使用相对路径，避免文件迁移后路径找不到而导致问题，建议一篇博客单独创建一个文件夹进行图片的存储便于管理。<br>  CSDN中的图片注释无法显示，必须通过在图片下添加<code>&lt;center&gt;添加图片注释&lt;/font&lt;/center&gt;</code>的方式进行注释。</p><blockquote><center>添加图片注释</center></blockquote><p>  网上其他博主也有推荐使用<a href="https://portal.qiniu.com/signin?redirect=%2Fhome">七牛云存储</a>的，将图片从本地上传到七牛云存储仓库。得到一个外链地址，将外链地址作为图片的URL地址写进文章。</p><p><strong>2.数学公式</strong><br>CSDN中默认<code>latex</code>的格式是可以进行渲染的，而在<code>Hexo</code>中需要在全局配置文件中进行修改：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br><span class="hljs-section"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br>math:<br>  # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 <span class="hljs-code">`math: true`</span><br>  # If you want to use math on the custom page, you need to set <span class="hljs-code">`math: true`</span> in Front-matter<br>  enable: true<br><br>  # 开启后，只有在文章 Front-matter 里指定 <span class="hljs-code">`math: true`</span> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度<br>  # If true, only set <span class="hljs-code">`math: true`</span> in Front-matter will enable math, to load faster when the page does not contain math<br>  specific: false<br></code></pre></td></tr></tbody></table></figure><p>封面来源：<a href="https://www.youtube.com/watch?v=XiMVwkxu3hU">如何使用Hexo+Github Pages 搭建个人博客，手把手最新教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Blogging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>From OpenCV to YOLOv5</title>
    <link href="/2025/07/09/other/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/"/>
    <url>/2025/07/09/other/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/</url>
    
    <content type="html"><![CDATA[<p><strong>本文系统性地研究了目标检测技术从传统方法到深度学习的演进过程，对比分析了OpenCV级联分类器与YOLOv5算法全套及其衍生玩法。</strong></p> <span id="more"></span><h1>From OpenCV to YOLOv5: Object Detection from Theory to Practice</h1><div class="note note-primary">            <p><strong>摘要</strong>：本文系统性地研究了目标检测技术从传统方法到深度学习的演进过程，重点对比分析了 <em><strong>OpenCV级联分类器</strong></em> 与 <em><strong>YOLOv5</strong></em> 的核心原理、技术特点及适用场景。通过深入研究<em><strong>Haar特征</strong></em> 与 <em><strong>卷积神经网络</strong></em> 的特征提取机制，揭示了两种方法在检测精度、计算效率等方面的本质差异。在实践层面，详细探讨了使用<em><strong>Labelme</strong></em>进行<em><strong>数据标注</strong></em>的方法论，以及如何利用 <em><strong>Roboflow</strong></em> 等平台获取和优化训练数据集。基于上述理论研究，我们将YOLOv5模型部署至 <em><strong>树莓派嵌入式平台</strong></em> ，实现了垃圾分类目标检测系统的工程化应用。本研究不仅梳理了目标检测技术的发展脉络，更通过完整的 <em><strong>“理论-数据-训练-部署”</strong></em> 闭环验证了深度学习人工智能在资源受限设备上的实用价值。</p>          </div><div class="note note-primary">            <p><strong>关键词</strong>：<em><strong>OpenCV；YOLOv5；目标检测；树莓派</strong></em></p>          </div><div class="note note-primary">            <p><strong>引言</strong>：每天清晨，当我们拿起智能手机解锁时，人脸识别功能会瞬间完成身份验证；走进机场安检区，摄像头会自动标记旅客的面部位置；甚至社交软件中的“美颜滤镜”，也需要先精准定位五官。这些看似简单的功能，其实背后都依赖于图像处理的目标检测技术！</p>          </div><p>  而在早期，这类技术并非基于复杂的深度学习，而是通过OpenCV的级联检测器（如Haar级联）实现的。</p><h3 id="一、OpenCV中Python-环境搭建">一、OpenCV中Python 环境搭建</h3><p>  Python 环境搭建是实现目标检测的前提基础，而其环境也并不复杂，仅仅是在Python解释器的基础上添加诸如numpy、matplotlib等库即可。</p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%871.png" alt="图1 OpenCV环境搭建所需要的软件包示例"></p><h3 id="二、OpenCV的级联分类器">二、OpenCV的级联分类器</h3><p>  Haar分类器是一种基于机器学习的目标检测算法，它使用Haar特征描述图像中的目标。Haar特征是基于图像亮度的局部差异计算得出的，可以用来描述目标的边缘、角落和线条等特征。<br>  将一系列简单的分类器按照一定的顺序级联到一起就构成了级联分类器，使用级联分类器的程序可以通过一系列简单的判断来对样本进行识别。OpenCV提供一些已经训练好的级联分类器，有人脸检测、身形检测、车牌检测等，如下图所示。想要实现哪一种图像检测，在程序启动时加载对应的级联分类器即可。</p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%872.png" alt="图2 OpenCV自带的级联分类器XML文件"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">face_detection</span>(<span class="hljs-params">frame</span>):<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + <span class="hljs-string">'haarcascade_frontalface_default.xml'</span>)<br>    faces = face_cascade.detectMultiScale(gray, scaleFactor=<span class="hljs-number">1.05</span>, minNeighbors=<span class="hljs-number">9</span>, minSize=(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>))<br>    <span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> faces:<br>        cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>        cv2.putText(frame, <span class="hljs-string">"Face"</span>, (x, y - <span class="hljs-number">10</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="hljs-number">0.9</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> frame<br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ret, frame = cap.read()<br>    result = face_detection(frame)<br>    cv2.imshow(<span class="hljs-string">"Face Detection"</span>, result)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure><h3 id="三、调用级联分类器实现检测">三、调用级联分类器实现检测</h3><p>  作为传统机器视觉的AI方法，人脸级联分类器采用提取眼睛区域（上暗下亮）、鼻梁区域（两侧暗中间亮）、嘴巴区域（上唇暗下唇亮）、面部轮廓（与背景的明暗对比）等多个特征的方法进行检测，效果图如下图所示。</p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%873.png" alt="图4 使用OpenCV人脸级联分类器进行人脸检测效果图"></p><p>  尽管Haar级联在早期表现出色，但是随着场景扩展，传统方法OpenCV图像处理的弊端逐渐开始显现，级联的方法遇到了瓶颈，其局限性在复杂场景中暴露无遗：<br>(1)光照敏感：强光下人脸过曝时，特征对比度消失，导致漏检。<br>(2)姿态与遮挡：侧脸或戴口罩时，矩形特征失效，误检率飙升。<br>(3)多目标处理困难：需手动调整参数适应不同目标（如猫脸检测需重新训练）。<br>Haar级联的失败案例：背光导致检测失败：树叶被误检测为人脸。</p><p>  从“人工规则”到“智能学习”，随着OpenCV传统图像处理方法的失宠，一种运用前沿AI——深度学习算法的新目标检测方法应运而生：YOLO算法！YOLOv5的诞生标志着目标检测从人工设计规则转向数据驱动学习，他们有着诸多的不同：<br>(1)特征提取的自动化：Haar级联依赖工程师设计的黑白矩形块，而YOLOv5通过训练自动提取更复杂的特征（例如纹理、轮廓、语义信息）。<br>(2)全局理解图像：传统方法需滑动窗口逐区域扫描，YOLOv5将图像划分为网格，单次预测所有目标的位置和类别，效率提升百倍。</p><h3 id="四、YOLOv5运行环境的搭建">四、YOLOv5运行环境的搭建</h3><p>  这个的步骤可能略显复杂，主要是安装anaconda，为YOLOv5的运行创建虚拟环境，安装cuda，再根据电脑具体配置是否有GPU选择pytorch的版本。</p><h3 id="五、YOLOv5的运行">五、YOLOv5的运行</h3><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%875.png" alt="图 5 PC成功调用GPU进行YOLOv5 目标检测"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%876.png" alt="图 6 YOLOv5 默认图像的处理结果（1）"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%877.png" alt="图 7 YOLOv5 默认图像的处理结果（2）"></p><p>  从OpenCV的“人工经验”到YOLOv5的“数据智能”，目标检测技术实现了质的飞跃。然而，YOLOv5的强大性能离不开高质量的数据支撑，但是现实生活中我们的需求是多样化的，此时我们不满足于仅仅使用YOLOv5默认的数据集进行目标检测，这时我们将深入探讨如何构建专属数据集：</p><h3 id="六、用labelme进行数据集的标注-4">六、用labelme进行数据集的标注[4]</h3><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%878.png" alt="图 8 使用labelme手动进行数据集标注"></p><p>  Labelme确实能够适应特定需求进行数据集的划分了，但是一次的训练需要成百上千张图片，每做一次数据集就需要手动划分这么多，显然效率较低，难以大规模推广使用，于是我们可以通过下载网络平台上的各种标注好数据集进行训练实验。</p><h3 id="七、用roboflow下载数据集-5">七、用roboflow下载数据集[5]</h3><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%879.png" alt="图 9 在Roboflow中寻找合适的数据集"></p><h3 id="八、对数据集进行训练和测试">八、对数据集进行训练和测试</h3><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8710.png" alt="图 10 对数据集进行训练"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8711.png" alt="图 11 获取训练好的特征权重文件"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8712.png" alt="在图 12 训练所得混淆矩阵"></p><p>  列代表预测的类别，行代表实际的类别。其对角线上的值表示预测正确的数量比例，非对角线元素则是预测错误的部分。混淆矩阵的对角线值越高越好，这表明许多预测是正确的。</p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8713.png" alt="图13 训练所得labels"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8714.png" alt="图14 训练所得准确率与置信度"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8715.png" alt="图15 训练所得"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8716.png" alt="图16 个人“手势”数据集测试（1）"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8717.png" alt="图17 个人“手势”数据集测试（2）"></p><p>  为了将目标检测技术从理论转化为实际应用，我们决定将YOLOv5模型部署到嵌入式设备中，打造具有实用价值的智能终端。考虑到深度学习算法对计算性能的较高要求，传统的C51、STM32等单片机难以满足运算需求，因此我们选择了性能更为强大的树莓派作为硬件平台，以确保模型能够高效稳定地运行。这一方案不仅提升了系统的实时处理能力，也为后续的功能扩展提供了充足的计算资源保障。</p><h3 id="九、部署至树莓派装置进行实战检测">九、部署至树莓派装置进行实战检测</h3><p>  在系统实现过程中，我们针对树莓派的硬件特性进行了适配性开发。由于树莓派采用CSI摄像头接口，其图像采集方式与PC端的USB摄像头存在差异，为此我们专门优化了图像采集模块的代码架构。同时，通过设计高效的通信协议，实现了树莓派与主控芯片STM32的协同工作。</p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8718.png" alt="图18 在树莓派中配置anaconda"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8719.png" alt="图19 在树莓派中配置vscode"></p><p><img src="https://raw.githubusercontent.com/Richard110206/blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8720.png" alt="图20 对树莓派进行调试"></p><p>  历经反复的调试，最终完成了基于YOLOv5的智能垃圾分类系统，在自主构建的数据集支持下，能够准确识别多种垃圾类型，并通过机械执行实现自动分类压缩回收，充分展现了人工智能深度学习技术的实用价值！</p><h3 id="参考文献">参考文献</h3><p>[1]陈之尧.基于OpenCV-Python的图像分割技术的设计与应用研究[J].中国新通信,2018,20(19):89.<br>[2]明月科技.《Python OpenCV快速从入门到精通》.<br>[3]<a href="https://blog.csdn.net/qq_67105081/article/details/138232424?ops_request_misc=%7B%22request_id%22%3A%22b368614c237378c5bf41ba67bb6c3883%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=b368614c237378c5bf41ba67bb6c3883&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-138232424-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=yolov5%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA&amp;spm=1018.2226.3001.4187">深度学习目标检测：yolov5环境配置，适合0基础小白，超详细-CSDN博客</a><br>[4]<a href="https://blog.csdn.net/weixin_45736855/article/details/129583272?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=yolov5%E7%9A%84labelme%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E9%9B%86&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-129583272.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187">labelme制作yolov5模型的数据集_labelme yolo-CSDN博客</a><br>[5]<a href="https://blog.csdn.net/2401_86849688/article/details/145814831?spm=1001.2014.3001.5501">下载数据集进行yolov5的训练测试_yolov5数据集下载-CSDN博客</a><br>[6]<a href="https://blog.csdn.net/qq_45305490/article/details/125219937?ops_request_misc=%7B%22request_id%22%3A%22d18d63f66eeb3c007e4fab2cfbb532b2%22%2C%22scm%22%3A%2220140713.130102334.pc_all.%22%7D&amp;request_id=d18d63f66eeb3c007e4fab2cfbb532b2&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125219937-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=yolov5%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84runs%20train&amp;spm=1018.2226.3001.4187">yolov5-runs文件中对train结果的说明_train box loss-CSDN博客</a><br>[7]<a href="https://blog.csdn.net/2401_86849688/article/details/145858990?spm=1001.2014.3001.5501">将yolov5运用在树莓派上进行目标检测_树莓派yolo5调用摄像头-CSDN博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
      <tag>yolov5</tag>
      
      <tag>object detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUMT-Datastructure-Practice 4</title>
    <link href="/2025/06/27/Data%20structure/CUMT-Datastructure-Practice-4/"/>
    <url>/2025/06/27/Data%20structure/CUMT-Datastructure-Practice-4/</url>
    
    <content type="html"><![CDATA[<p><strong>数据结构实验4，涉及哈希表、排序、优先队列相关问题，包含重要知识点的解析、解题思路和完整代码。</strong></p> <span id="more"></span><h2 id="问题-A-机器人王国里的路径长度">问题 A: 机器人王国里的路径长度</h2><h4 id="题目描述">题目描述</h4><p>在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路的长度不同。第N层的卫星城不再分出新的卫星城。现在人类只探知到所有直接相连的城市间的路程，你能计算某个卫星城到达首都的路程吗？</p><h4 id="输入">输入</h4><p>第一行为N，表示机器人王国里有N层卫星城，N最大为10。从第二行开始，共2N+1-2行，每行分别是城市的代号到其分出的卫星城的代号和它们间的路程。 代号用若干个字母表示，直连路程最大为100。最后一行是某卫星城的代号。</p><h4 id="输出">输出</h4><p>根据最后一行的卫星城代号，求该卫星城到首都的路程。</p><h4 id="样例输入">样例输入</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">2</span><br><span class="hljs-selector-tag">A</span> F <span class="hljs-number">20</span><br><span class="hljs-selector-tag">B</span> D <span class="hljs-number">100</span><br><span class="hljs-selector-tag">G</span> <span class="hljs-selector-tag">A</span> <span class="hljs-number">5</span><br><span class="hljs-selector-tag">G</span> <span class="hljs-selector-tag">B</span> <span class="hljs-number">10</span><br><span class="hljs-selector-tag">A</span> C <span class="hljs-number">6</span><br><span class="hljs-selector-tag">B</span> E <span class="hljs-number">30</span><br>D<br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">110<br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析">问题分析</h4><p>本题需要根据当前<code>target</code>不断向上回溯寻找其父节点，将<code>distance</code>值返回加入到总路程<code>sum</code>中即可，这里使用哈希表(unordered_map)存储每个城市的父城市和到父城市的距离。</p><h4 id="完整代码">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span><span class="hljs-comment">//哈希表容器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span><span class="hljs-comment">//处理字符串</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span><span class="hljs-comment">//这里用于幂运算</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">city</span> {<br>string parent;<span class="hljs-comment">//父城市名称</span><br><span class="hljs-type">int</span> distance;<span class="hljs-comment">//到父城市的距离</span><br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>unordered_map&lt;string, city&gt; path;<span class="hljs-comment">//存储城市路径关系的哈希表</span><br><span class="hljs-type">int</span> N;<br>cin &gt;&gt; N;<br><span class="hljs-type">int</span> number = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, N + <span class="hljs-number">1</span>) - <span class="hljs-number">2</span>;<span class="hljs-comment">//计算读取的城市个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; number;i ++) {<br>string start, end;<br><span class="hljs-type">int</span> distance;<br>cin &gt;&gt; start &gt;&gt; end &gt;&gt; distance;<br>path[end] = { start,distance };<span class="hljs-comment">//进行存储</span><br>}<br>string target;<br>cin &gt;&gt; target;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (path.<span class="hljs-built_in">find</span>(target)!=path.<span class="hljs-built_in">end</span>()){<br><span class="hljs-comment">//直至当前的目标城市无法查找到父城市是停止</span><br>sum += path[target].distance;<br>target = path[target].parent;<span class="hljs-comment">//将当前目标城市向上移动</span><br>}<br>cout &lt;&lt; sum &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="注释">注释</h4><p><code>&lt;unordered_map&gt;</code>是C++标准库中提供无序关联容器的头文件，它实现了基于哈希表的键值对存储结构，它具有以下特性：</p><ul><li>元素无序存储，不会根据关键字值或映射值按任何特定顺序排序</li><li>键必须唯一（不允许重复键）</li><li>根据关键字来引用，而不是根据索引来引用</li><li>使用链表处理哈希冲突（链地址法）</li></ul><p>构造哈希表：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;KeyType, ValueType&gt; map_name;<br></code></pre></td></tr></tbody></table></figure><ol><li>元素访问：</li></ol><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td><code>map[key]</code></td><td>访问或插入元素（键不存在时自动插入并值初始化）</td></tr><tr><td><code>map.at(key)</code></td><td>安全访问元素（键不存在时抛出out_of_range异常）</td></tr><tr><td><code>map.find(key)</code></td><td>返回指向元素的迭代器（未找到时返回end()）</td></tr></tbody></table><ol start="2"><li>容量查询：</li></ol><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td><code>map.empty()</code></td><td>判断容器是否为空</td></tr><tr><td><code>map.size()</code></td><td>返回元素个数</td></tr></tbody></table><ol start="3"><li>修改操作：</li></ol><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td><code>map.insert({key, value})</code></td><td>插入键值对（返回pair&lt;iterator, bool&gt;）</td></tr><tr><td><code>map.emplace(key, value)</code></td><td>直接构造元素（避免临时对象）</td></tr><tr><td><code>map.erase(key)</code></td><td>删除指定键的元素</td></tr></tbody></table><p>insert()&amp;&amp;emplace()的区别：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map.<span class="hljs-built_in">insert</span>({<span class="hljs-string">"apple"</span>, <span class="hljs-number">2</span>});<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">"apple"</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>查找与统计</li></ol><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td><code>map.count(key)</code></td><td>返回关键字出现的次数</td></tr><tr><td><code>map.contains(key)</code></td><td>检查键是否存在（返回bool）</td></tr></tbody></table><h2 id="问题-D-寻找第二小的数">问题 D: 寻找第二小的数</h2><h4 id="题目描述-v2">题目描述</h4><p>求n个整数中第二小的数。<br>相同的整数看成一个数。比如，有5个数分别是1,1,3,4,5，那么第二小的数就是3。</p><h4 id="输入-v2">输入</h4><p>输入包含多组测试数据。输入的第一行是一个整数C，表示有C组测试数据；<br>每组测试数据的第一行是一个整数n，表示本组测试数据有n个整数（2&lt;=n&lt;=10），接着一行是n个整数（每个数均小于100）。</p><h4 id="输出-v2">输出</h4><p>为每组测试数据输出第二小的整数，如果不存在第二小的整数则输出“NO”，每组输出占一行。</p><h4 id="样例输入-v2">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v2">样例输出</h4><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-keyword">NO</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v2">问题分析</h4><p>用逆序的优先队列即可完成！</p><h4 id="完整代码-v2">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">()</span> </span>{<br>priority_queue &lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br><span class="hljs-type">int</span> m;<br>cin &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) {<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>pq.<span class="hljs-built_in">push</span>(a);<br>}<br><span class="hljs-type">int</span> min = pq.<span class="hljs-built_in">top</span>();<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>() &amp;&amp; min == pq.<span class="hljs-built_in">top</span>()) {<br>pq.<span class="hljs-built_in">pop</span>();<br>}<br><span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">empty</span>()) {<br>cout &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br><span class="hljs-built_in">find</span>();<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="问题-E-按十进制各位和排序">问题 E: 按十进制各位和排序</h2><h4 id="题目描述-v3">题目描述</h4><p>对于给定的正整数序列，按照每个数的十进制形式各个位上的数之和从大到小排序，各个位上的数和相同的按照本身大小排序，大的在前，小的在后。</p><h4 id="输入-v3">输入</h4><p>第一行 1 个整数 n,表示序列的大小。( 0 &lt; n ≤ 1000) 第二行 n 个正整数，表示序列的每个数，每个数不大于 100000000。</p><h4 id="输出-v3">输出</h4><p>输出按照题目要求排序后的序列。</p><h4 id="样例输入-v3">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><br><span class="hljs-symbol">17 </span><span class="hljs-number">26</span> <span class="hljs-number">9</span> <span class="hljs-number">13</span> <span class="hljs-number">88</span> <span class="hljs-number">22</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v3">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">88 </span><span class="hljs-number">9</span> <span class="hljs-number">26</span> <span class="hljs-number">17</span> <span class="hljs-number">22</span> <span class="hljs-number">13</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v3">问题分析</h4><p>要将其十进制排序后的结果与原本大小匹配，这里使用了冒泡排序完成。</p><h4 id="完整代码-v3">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{<span class="hljs-comment">//十进制各个位数求和函数</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>) {<br>sum += a % <span class="hljs-number">10</span>;<br>a = a / <span class="hljs-number">10</span>;<br>}<br><span class="hljs-keyword">return</span> sum;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">order</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br>cin &gt;&gt; order[i];<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n ; i++) {<span class="hljs-comment">//进行冒泡排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ;j &lt; n-i<span class="hljs-number">-1</span>;j++) {<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Sum</span>(order[j]) &lt; <span class="hljs-built_in">Sum</span>(order[j + <span class="hljs-number">1</span>]) ||<br>(<span class="hljs-built_in">Sum</span>(order[j]) == <span class="hljs-built_in">Sum</span>(order[j + <span class="hljs-number">1</span>]) &amp;&amp; order[j] &lt; order[j + <span class="hljs-number">1</span>])) {<br><span class="hljs-type">int</span> temp=order[j];<br>order[j]=order[j<span class="hljs-number">+1</span>];<br>order[j<span class="hljs-number">+1</span>]=temp;<br>}<br>}<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++) {<br>cout&lt;&lt;order[i]&lt;&lt;<span class="hljs-string">" "</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="问题-F-奇偶数的排序">问题 F: 奇偶数的排序</h2><h4 id="题目描述-v4">题目描述</h4><p>给你10个正整数，其中5个奇数、5个偶数，先递减排奇数，然后再递增排偶数。请编程实现。</p><h4 id="输入-v4">输入</h4><p>一行10个正整数（int类型范围）。</p><h4 id="输出-v4">输出</h4><p>先递减排5个奇数，然后再递增排5个偶数，各个数之间有一个空格间隔。</p><h4 id="样例输入-v4">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v4">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v4">问题分析</h4><p>分别使用优先队列和逆序优先队列对奇数偶数进行排序，再依次输出队首元素。</p><h4 id="完整代码-v4">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>priority_queue&lt;<span class="hljs-type">int</span>&gt; odd;<span class="hljs-comment">//奇数的优先队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;  even;<span class="hljs-comment">//偶数逆序优先队列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++) {<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br><span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<br>even.<span class="hljs-built_in">push</span>(a);<br>}<br><span class="hljs-keyword">else</span> odd.<span class="hljs-built_in">push</span>(a);<br>}<br><span class="hljs-keyword">while</span>(!odd.<span class="hljs-built_in">empty</span>()) {<br>cout &lt;&lt; odd.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">" "</span>;<br>odd.<span class="hljs-built_in">pop</span>();<br>}<br><span class="hljs-keyword">while</span> (!even.<span class="hljs-built_in">empty</span>() ){<br>cout &lt;&lt; even.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">" "</span>;<br>even.<span class="hljs-built_in">pop</span>();<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>封面来源：: <a href="https://www.youtube.com/watch?v=FsfRsGFHuv4">Learn Hash Tables in 13 minutes</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hashtable</tag>
      
      <tag>sort</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUMT-Datastructure-Practice 3</title>
    <link href="/2025/06/24/Data%20structure/CUMT-Datastructure-Practice-3/"/>
    <url>/2025/06/24/Data%20structure/CUMT-Datastructure-Practice-3/</url>
    
    <content type="html"><![CDATA[<p><strong>数据结构实验3，涉及链表存储二叉树、哈夫曼树、优先队列、Dijkstra算法、Kruskal算法，包含重要知识点的解析、解题思路和完整代码。</strong></p> <span id="more"></span><h2 id="问题-A-二叉链表存储的二叉树">问题 A: 二叉链表存储的二叉树</h2><h4 id="题目描述">题目描述</h4><p>树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构.在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。</p><h4 id="输入">输入</h4><p>输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。</p><h4 id="输出">输出</h4><p>共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。</p><h4 id="样例输入">样例输入</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ABC  DE <span class="hljs-selector-tag">G</span>  F <br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">B</span> C D E <span class="hljs-selector-tag">G</span> F <br>C <span class="hljs-selector-tag">B</span> E <span class="hljs-selector-tag">G</span> D F <span class="hljs-selector-tag">A</span> <br>C <span class="hljs-selector-tag">B</span> E <span class="hljs-selector-tag">G</span> D F <span class="hljs-selector-tag">A</span><br></code></pre></td></tr></tbody></table></figure><h4 id="提示">提示</h4><p>遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。</p><h4 id="问题分析">问题分析</h4><p>本题依照题目使用二叉树链式存储结构进行二叉树的建立和遍历。</p><ol><li>设计二叉树的<code>struct</code>的节点结构，包含数据元素和左子叶节点和右子叶节点（使用构造函数给结点赋初值和初始化节点指针）。</li><li>用递归的思想实现二叉树的构建，若索引值<code>index</code>非空，则构建节点，再依次递归构建左子树，递归构建右子树。</li><li>递归遍历注意访问和递归的调用顺序即可。</li></ol><table><thead><tr><th>遍历方式</th><th>访问顺序</th><th>递归调用顺序</th></tr></thead><tbody><tr><td>先序遍历</td><td>根 → 左 → 右</td><td>访问 → 左递归 → 右递归</td></tr><tr><td>中序遍历</td><td>左 → 根 → 右</td><td>左递归 → 访问 → 右递归</td></tr><tr><td>后序遍历</td><td>左 → 右 → 根</td><td>左递归 → 右递归 → 访问</td></tr></tbody></table><h4 id="完整代码">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryTreeNode</span> {<br><span class="hljs-type">char</span> data;<br>BinaryTreeNode* left;<br>BinaryTreeNode* right;<br><span class="hljs-built_in">BinaryTreeNode</span>(<span class="hljs-type">char</span> x):<span class="hljs-built_in">data</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>){}<br>};<br><span class="hljs-comment">//若不构造函数则创建节点时需要:</span><br><span class="hljs-comment">//BinaryTreeNode* node = new BinaryTreeNode{'A', nullptr, nullptr};</span><br><span class="hljs-function">BinaryTreeNode* <span class="hljs-title">buildtree</span><span class="hljs-params">(string str, <span class="hljs-type">int</span>&amp; index)</span> </span>{<br><span class="hljs-keyword">if</span> (index &gt;= str.<span class="hljs-built_in">size</span>() || str[index] == <span class="hljs-string">' '</span>) {<br><span class="hljs-comment">//若索引值超出范围或者为空</span><br>index++;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>}<br>BinaryTreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryTreeNode</span>(str[index++]);<br><span class="hljs-comment">//创建新节点，递归构建左右子树</span><br>node-&gt;left = <span class="hljs-built_in">buildtree</span>(str, index);<br>node-&gt;right = <span class="hljs-built_in">buildtree</span>(str, index);<br><span class="hljs-keyword">return</span> node;<br>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(BinaryTreeNode* root)</span> </span>{<span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) {<br><span class="hljs-keyword">return</span>;<br>}<br>cout &lt;&lt; root-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;<br><span class="hljs-built_in">preOrder</span>(root-&gt;left);<br><span class="hljs-built_in">preOrder</span>(root-&gt;right);<br>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(BinaryTreeNode* root)</span> </span>{<span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) {<br><span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>cout &lt;&lt; root-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;<br><span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>};<br><span class="hljs-comment">//void postOrder(BinaryTreeNode* root) {后序遍历</span><br><span class="hljs-comment">//if (root == nullptr) {</span><br><span class="hljs-comment">//return;</span><br><span class="hljs-comment">//}</span><br><span class="hljs-comment">//postOrder(root-&gt;left);</span><br><span class="hljs-comment">//postOrder(root-&gt;right);</span><br><span class="hljs-comment">//cout &lt;&lt; root-&gt;data &lt;&lt; " ";</span><br><span class="hljs-comment">//};</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>string str;<br><span class="hljs-built_in">getline</span>(cin,str);<br><span class="hljs-comment">//注意用getline需要读取空格</span><br><span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>BinaryTreeNode* root=<span class="hljs-built_in">buildtree</span>(str, index);<br><span class="hljs-built_in">preOrder</span>(root);<br>cout &lt;&lt; endl;<br><span class="hljs-built_in">inOrder</span>(root);<br>cout &lt;&lt; endl;<br><span class="hljs-built_in">inOrder</span>(root);<br>cout &lt;&lt; endl;<br><span class="hljs-comment">//postOrder(root);</span><br><span class="hljs-comment">//cout &lt;&lt; endl;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="B题：哈夫曼树">B题：哈夫曼树</h2><h4 id="题目描述-v2">题目描述</h4><p>哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有叶子结点的路径长度与权值的乘积之和。</p><h4 id="输入-v2">输入</h4><p>输入有多组数据。<br>每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。</p><h4 id="输出-v2">输出</h4><p>输出权值。</p><h4 id="样例输入-v2">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">8</span> <br><span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">11</span> <span class="hljs-number">30</span> <br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v2">样例输出</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">10<br>62<br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v2">问题分析</h4><ol><li>将所有权值作为单独的树（每个树只有一个节点）</li><li>每次选择权值最小的两棵树合并，形成新的子树，新树的权值为两子树权值之和</li><li>将新树根节点作为新的子树，重复上述过程，直到只剩下一棵树</li><li>计算合并过程中所有中间结果的累加和</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">huffman</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>priority_queue &lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; minqueue;<br><span class="hljs-comment">//创建最小优先队列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>minqueue.<span class="hljs-built_in">push</span>(a);<br>}   <span class="hljs-comment">// 读取n个权值并存入最小堆</span><br><span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<span class="hljs-comment">//带权路径长度</span><br><span class="hljs-comment">// 隐式构建哈夫曼树</span><br><span class="hljs-keyword">while</span> (!minqueue.<span class="hljs-built_in">empty</span>()) {<br><span class="hljs-type">int</span> parent = minqueue.<span class="hljs-built_in">top</span>();<br>minqueue.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">//取出当前最小值</span><br><span class="hljs-keyword">if</span> (minqueue.<span class="hljs-built_in">empty</span>()) {<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//当队列中只有一个元素时退出循环</span><br>}<br>parent += minqueue.<span class="hljs-built_in">top</span>();<br>minqueue.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">//取出次小值</span><br>total +=  parent;<br>minqueue.<span class="hljs-built_in">push</span>(parent);<br>}<br>cout &lt;&lt; total &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n) {<br><span class="hljs-built_in">huffman</span>(n);<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="注释">注释</h4><p><strong>优先队列：</strong> 这是一种特殊的队列，每次<code>push</code>进去一个数，它就会自动按照大小排好队，<code>top</code>就能得到队首元素（最大值），<code>pop</code>就会弹出队首元素（队列中最大值）。定义方法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<span class="hljs-comment">//int型优先队列</span><br></code></pre></td></tr></tbody></table></figure><p>若我们不满足其降序排列我们还可以将其调整为升序排列：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue &lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<span class="hljs-comment">//int型逆序优先队列</span><br></code></pre></td></tr></tbody></table></figure><h2 id="C题：树的遍历">C题：树的遍历</h2><h4 id="题目描述-v3">题目描述</h4><p>  假设二叉树中的所有键值都是不同的正整数。唯一的二元树可以通过给定的后序和顺序遍历序列，或前序和顺序遍历序列来确定。但是，如果仅给出后序和前序遍历序列，则相应的树可能不再是唯一的。<br>  现在给出一对后序和前序遍历序列，您应该输出树的相应的中序遍历序列。如果树不是唯一的，只需输出其中任何一个。</p><h4 id="输入-v3">输入</h4><p>每个输入文件包含一个测试用例。对于每种情况，第一行给出正整数N（≤30），即二叉树中的节点总数。第二行给出预订序列，第三行给出后序序列。一行中的所有数字都用空格分隔。</p><h4 id="输出-v3">输出</h4><p>对于每个测试用例，如果树是唯一的，则首先是行中的Yes，否则是No。然后在下一行中打印相应二叉树的中序遍历序列。如果解决方案不是唯一的，那么任何答案都可以。保证至少存在一种解决方案。一行中的所有数字必须用一个空格分隔，并且行的末尾不能有额外的空格。</p><h4 id="样例输入-v3">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v3">样例输出</h4><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Yes</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v3">问题分析</h4><p>  已知前序、中序二叉树唯一确定，已知中序、后序二叉树唯一确定，而一直前序和后序二叉树无法唯一确定。<br>  前序序列的第一个节点必于后续序列最后一个节点相同，为根节点；前序序列的第二个节点为左子树的根节点（如果有左子树的话），在后续序列中寻找该节点，则划分了左右子树，其左边的所有节点属于左子树，右边的节点（直到根节点之前）属于右子树。<br>  因而我们可以使用前序和后序序列递归地分割左右子树，并直接生成中序序列。<br>而如果前序的第二个节点在后序中位于根节点前的位置，说明该节点可以是左子树或右子树的根，此时树不唯一，可以任意选择左右子树。</p><h4 id="完整代码-v2">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; in, pre, post;<br><span class="hljs-comment">//定义全局变量，分别为前序、中序、后序序列</span><br><span class="hljs-type">bool</span> unique = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记二叉树是否唯一</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> preL, <span class="hljs-type">int</span> preR, <span class="hljs-type">int</span> postL, <span class="hljs-type">int</span> postR)</span> </span>{<br><span class="hljs-comment">//分别标记了前序和后序序列的左右边界</span><br>    <span class="hljs-keyword">if</span> (preL == preR) {<br>        in.<span class="hljs-built_in">push_back</span>(pre[preL]);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (pre[preL] == post[postR]) {<br>        <span class="hljs-type">int</span> i = preL + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= preR &amp;&amp; pre[i] != post[postR - <span class="hljs-number">1</span>]) i++;<br>        <span class="hljs-comment">//在后序序列中寻找左子树的根节点</span><br>        <span class="hljs-keyword">if</span> (i - preL &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">build</span>(preL + <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>, postL, postL + (i - preL - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>            unique = <span class="hljs-literal">false</span>;<br>        in.<span class="hljs-built_in">push_back</span>(post[postR]);<br>        <span class="hljs-built_in">build</span>(i, preR, postL + (i - preL - <span class="hljs-number">1</span>), postR - <span class="hljs-number">1</span>);<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    pre.<span class="hljs-built_in">resize</span>(n);<br>    post.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-comment">//为全局变量重新分配空间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp; val : pre) cin &gt;&gt; val;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp; val : post) cin &gt;&gt; val;<br>    <span class="hljs-comment">//读入数据（注意是&amp;索引值）</span><br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    cout &lt;&lt; (unique ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (!in.<span class="hljs-built_in">empty</span>()) {<br>        cout &lt;&lt; in[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; in.<span class="hljs-built_in">size</span>(); ++i)<br>            cout &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; in[i];<br>    }<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="D题：最短路径">D题：最短路径</h2><h4 id="题目描述-v4">题目描述</h4><p>一个迷宫地图中，多个房间由单向通道相连，房间号从1到N依次编号。你能编程求解任意房间间的最短路径长度吗？</p><h4 id="输入-v4">输入</h4><p>第一行是迷宫中的房间数N和单项通道数M（0&lt;N,M&lt;100），接下来M行，每行三个数x,y,z，表示一个通道是从x到y,且通道长度是z(z&lt;1000）。<br>最后一行是start和end，分别是起点房间号和终点房间号。</p><h4 id="输出-v4">输出</h4><p>输出起点房间号和终点房间号间的最短路径长度。如果没有通路，输出STOP。</p><h4 id="样例输入-v4">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v4">样例输出</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v4">问题分析</h4><p>最短路径路径问题，我们这里采用<strong>Dijkstra算法</strong>进行求解。</p><ol><li>构造邻接矩阵<code>graph</code>存储带权有向图。</li><li>将起始顶点的距离设为0，其他所有顶点的距离<code>distance</code>设为无穷大（即从<code>start</code>到<code>i</code>的最短路径长度）。</li><li>将起始顶点加入已访问集合<code>visited</code>。</li><li>遍历未访问顶点，找出距离起始点最短的顶点，将其加入已访问集合。</li><li>更新<code>distance</code>的距离，如果新计算的距离小于当前距离，则更新距离。</li><li>重复步骤3和4，直到所有顶点都被访问过。</li></ol><h4 id="完整代码-v3">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> M, N;<br>cin &gt;&gt; N &gt;&gt; M;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">distance</span>(N, INT_MAX);<span class="hljs-comment">//存放start到i点的最短路径长度</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(N, <span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//记录当前顶点是否已被访问过</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(N, <span class="hljs-number">0</span>));<br><span class="hljs-comment">//有向图的邻接矩阵（二维数组）</span><br><span class="hljs-type">int</span> p, q, length;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; M;i++){<br>cin &gt;&gt; p &gt;&gt; q &gt;&gt; length;<br>graph[p<span class="hljs-number">-1</span>][q<span class="hljs-number">-1</span>] = length;<br><span class="hljs-comment">//均采用 0-based索引</span><br>}<br><span class="hljs-type">int</span> start, end;<br>cin &gt;&gt; start &gt;&gt; end;<br>visited[start - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>distance[start - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++) {<br><span class="hljs-keyword">if</span> (graph[start - <span class="hljs-number">1</span>][i] != <span class="hljs-number">0</span>) {<br>distance[i] = graph[start - <span class="hljs-number">1</span>][i];<br><span class="hljs-comment">//用start的邻接矩阵对distance数组进行初始化</span><br>}<br>}<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j &lt;N;j++){<br><span class="hljs-type">int</span> small = INT_MAX;<br><span class="hljs-type">int</span> tag = <span class="hljs-number">-1</span>;<span class="hljs-comment">//标记最小顶点的索引</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++) {<br><span class="hljs-keyword">if</span> (distance[i - <span class="hljs-number">1</span>] &lt; small &amp;&amp; !visited[i - <span class="hljs-number">1</span>]) {<br>small = distance[i - <span class="hljs-number">1</span>];<br>tag = i;<br>}<br>}<br><span class="hljs-keyword">if</span> (tag == <span class="hljs-number">-1</span>) {<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//若没有找到最小索引</span><br><span class="hljs-comment">//邻接矩阵已经全部遍历完成</span><br><span class="hljs-comment">//退出循环</span><br>}<br>visited[tag - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记已访问</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= N;i++) {<br><span class="hljs-keyword">if</span> (graph[tag - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]!=<span class="hljs-number">0</span> &amp;&amp; <br>distance[tag - <span class="hljs-number">1</span>] + graph[tag - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] &lt; distance[i - <span class="hljs-number">1</span>]) {<br>distance[i - <span class="hljs-number">1</span>] = distance[tag - <span class="hljs-number">1</span>] + graph[tag - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br><span class="hljs-comment">//如果当前路径为最短路径则进行更新</span><br>}<br>}<br>}<br><span class="hljs-keyword">if</span> (distance[end - <span class="hljs-number">1</span>] != INT_MAX) {<br>cout &lt;&lt; distance[end<span class="hljs-number">-1</span>] &lt;&lt; endl;<br>}<br><span class="hljs-comment">//若distance==INT_MAX，则没有通路</span><br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">"STOP"</span> &lt;&lt; endl;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="E题：最小生成树">E题：最小生成树</h2><h4 id="题目描述-v5">题目描述</h4><p>最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。<br>可以用连通网来表示n个城市以及n个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，赋于边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。<br>而在常用的最小生成树构造算法中，普里姆（Prim）算法是一种非常常用的算法。<br>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。</p><h4 id="输入-v5">输入</h4><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数，对于第i行的第j个整数，如果不为0，则表示第i个顶点和第j个顶点有直接连接且代价为相应的值，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。<br>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。</p><h4 id="输出-v5">输出</h4><p>只有一个整数，即最小生成树的总代价。请注意行尾输出换行。</p><h4 id="样例输入-v5">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v5">样例输出</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></tbody></table></figure><h4 id="提示-v2">提示</h4><p>在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。</p><h4 id="问题分析-v5">问题分析</h4><p>完成本题首先要掌握要掌握两种计算最小生成树的方法：普利姆（Prim）算法、克鲁斯卡尔（Kruskal）算法。（当然本题只要求使用普利姆算法）</p><ul><li>普利姆算法（+点）</li></ul><ol><li>选择任意一个顶点作为起始点，将其加入最小生成树中</li><li>从未选择的顶点中选择与现有生成树连线权重最小的顶点，将其加入到现有生成树中</li><li>重复上述步骤，直到最小生成树包含了图中的所有顶点。</li></ol><ul><li>克鲁斯卡尔算法（+边）</li></ul><ol><li>从不属于最小生成树的边中找到权值最小的边，判断最小边及其连接的两个顶点加入到最小生成树是否会形成环路。</li><li>若不形成环路，则将此最小边及其连接的顶点并入最小生成树。</li><li>若形成环路，则永远不再看此边，然后从剩下的且不属于最小生成树的边中，寻找权值最小的边。</li><li>重复上述步骤，直至所有顶点均连接在一起，并没有形成环路时，最小生成树就找到了。</li></ol><p>根据题意这里使用普利姆算法进行编程求解，用<code>key</code>记录当前生成树与各个顶点的最小值，<code>visited</code>记录当前顶点是否被访问，外循环<code>n</code>次，每次将一个顶点加入最小生成树中。</p><h4 id="完整代码-v4">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span><span class="hljs-comment">//用于INT_MAX的数组初始化</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrix</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) {<br>cin &gt;&gt; matrix[i][j];<span class="hljs-comment">//读入邻接矩阵</span><br>}<br>}<br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">key</span>(n,INT_MAX);<br><span class="hljs-comment">//记录当前生成树与各顶点的最小值并不断更新</span><br>vector &lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">//记录当前顶点是否已经被访问过</span><br>key[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录最小生成树的总权值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br><span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) {<br><span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; (u == <span class="hljs-number">-1</span> || key[j] &lt; key[u])) {<br>u = j;<span class="hljs-comment">//找到当前与生成树的最小权值点顶点</span><br>}<br>}<br>visited[u] = <span class="hljs-literal">true</span>;<br>total += key[u];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>;v &lt; n;v++) {<br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; matrix[u][v]!=<span class="hljs-number">0</span> &amp;&amp; matrix[u][v] &lt; key[v]) {<br>key[v] = matrix[u][v];<br><span class="hljs-comment">//对key生成树到顶点的最小值进行更新</span><br>}<br>}<br><br>}<br>cout &lt;&lt; total &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="注释-v2">注释</h4><p><code>&lt;climits&gt;</code>头文件，定义了与整数类型的大小和范围相关的宏常量，常用<code>INT_MAX</code>和<code>INT_MIN</code>对数组变量进行初始化。</p><p>封面来源: <a href="https://www.youtube.com/watch?v=j0OUwduDOS0">Shortest Path Algorithms Explained (Dijkstra’s &amp; Bellman-Ford)</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary tree</tag>
      
      <tag>queue</tag>
      
      <tag>huffman treem</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Kruskal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUMT-Datastructure-Assignment 2</title>
    <link href="/2025/06/18/Data%20structure/CUMT-Datastructure-Assignment-2/"/>
    <url>/2025/06/18/Data%20structure/CUMT-Datastructure-Assignment-2/</url>
    
    <content type="html"><![CDATA[<p><strong>数据结构作业2，涉及二叉树的构建，前序、中序、后序遍历问题，以及栈相关的问题，包含重要知识点的解析、解题思路和完整代码。</strong></p> <span id="more"></span><h2 id="A题：统计回文字符串">A题：统计回文字符串</h2><h4 id="题目描述">题目描述</h4><p>现在给你一个字符串S，请你计算S中有多少连续子串是回文串。</p><h4 id="输入">输入</h4><p>输入包含多组测试数据。每组输入是一个非空字符串，长度不超过5000。</p><h4 id="输出">输出</h4><p>对于每组输入，输出回文子串的个数。</p><h4 id="样例输入">样例输入</h4><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aba</span><br><span class="hljs-attribute">aa</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>3<br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析">问题分析</h4><p>先读取字符串<code>s</code>，采取从中心向两边进行扩展的方法，若回文字符串为奇数个字符则起始时中心均为<code>i</code>；若回文字符串为偶数个字符则起始时中心<code>i</code>和<code>i+1</code>，直至字符不匹配或者数组越界。</p><h4 id="注意点">注意点</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])<br></code></pre></td></tr></tbody></table></figure><p>和</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (s[left] == s[right]&amp;&amp;left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; n )<br></code></pre></td></tr></tbody></table></figure><p>在编译器中并不等同：应该先检查是否越界，否则可能出现未定义行为而报错<br><strong>短路求值规则</strong>：逻辑运算符 &amp;&amp; 会从左到右依次求值，如果前面的条件为 false，后面的条件不会被计算。第一种写法利用了短路规则，避免了非法内存访问；第二种写法则可能引发问题。</p><h4 id="完整代码">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countnumber</span><span class="hljs-params">(string s)</span> </span>{<br><span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br><span class="hljs-type">int</span> left = i;<br><span class="hljs-type">int</span> right = i;<br><br><span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) {<br>num++;<br>--left;<br>++right;<br>}<br>left = i, right = i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) {<br>num++;<br>--left;<br>++right;<br>}<br>}<br><span class="hljs-keyword">return</span> num;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>string s;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s) {<br>cout &lt;&lt; <span class="hljs-built_in">countnumber</span>(s) &lt;&lt; endl;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="B题：构建矩阵">B题：构建矩阵</h2><h4 id="题目描述-v2">题目描述</h4><p>现请你构建一个N*N的矩阵，第i行j列的元素为i与j的乘积。（i，j均从1开始）</p><h4 id="输入-v2">输入</h4><p>输入的第一行为一个正整数C，表示测试样例的个数。<br>然后是C行测试样例，每行为一个整数N（1&lt;=N&lt;=9），表示矩阵的行列数。</p><h4 id="输出-v2">输出</h4><p>对于每一组输入，输出构建的矩阵。</p><h4 id="样例输入-v2">样例输入</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br>4<br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v2">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span> <span class="hljs-number">12</span> <span class="hljs-number">16</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v2">问题分析</h4><ol><li>构造<code>printmatrix</code>的函数，主函数中每读入一个数，调用一次函数</li><li>观察矩阵，相当于每行是一个等差数列，公差等于所在行行数，每换一次行其公差+1即可。</li></ol><h4 id="完整代码-v2">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matrix</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>{<br><span class="hljs-type">int</span> d = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;n &lt;= i * i &amp;&amp; d&lt;=i;n += d) {<br>cout &lt;&lt; n &lt;&lt; <span class="hljs-string">" "</span>;<br><span class="hljs-keyword">if</span> (n == i * d) {<br>cout &lt;&lt; endl;<br>d++;<br>n = <span class="hljs-number">0</span>;<br>}<br>}<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++) {<br>cin &gt;&gt; i;<br><span class="hljs-built_in">matrix</span>(i);<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>构造打印矩阵函数的另外一种做法，双层嵌套<strong>for</strong>循环，这个方法显然更加直观:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; ++i) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= N; ++j) {<br>            cout &lt;&lt; i * j;<br>            <span class="hljs-keyword">if</span> (j &lt; N) {<br>                cout &lt;&lt; <span class="hljs-string">" "</span>;<br>            }<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="C题：找规律填数字">C题：找规律填数字</h2><h4 id="题目描述-v3">题目描述</h4><p>小宇正在读小学，今天老师布置了几道数学题目。小宇平时上课经常不专心，这些他可发愁了，怎么办呢？看看你能不能帮帮他。<br>题目是给你一组有规律序列的前面5个整数，请你给出它后面跟着的5个整数，如：1,2,3,4,5,_, _, _, _, _, _。这是个等差数列，后面应该是6,7,8,9,10，就这么简单。而且现在小宇已经知道这串序列要么是等差数列，要么是等比数列或者是斐波那契数列。</p><h4 id="输入-v3">输入</h4><p>输入包含多组测试数据。每组输入5个整数，每个数字之间隔一个空格，当5个数字都为0时输入结束。</p><h4 id="输出-v3">输出</h4><p>对于每组输入，输出这串数列的后面5个数字，每个数字之间隔一个空格。</p><h4 id="样例输入-v3">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v3">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">32 </span><span class="hljs-number">64</span> <span class="hljs-number">128</span> <span class="hljs-number">256</span> <span class="hljs-number">512</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">21</span> <span class="hljs-number">34</span> <span class="hljs-number">55</span> <span class="hljs-number">89</span><br></code></pre></td></tr></tbody></table></figure><h4 id="注意点-v2">注意点</h4><p>参数变量较多，在<code>if</code>条件判断语句中要尽可能的将每个参数都包含进去，减小数据巧合而错判数列类型发生的可能性，博主一开始只通过三个参数就判断了数列的类型，就被特殊情况爆破了。</p><h4 id="完整代码-v3">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">predictNext</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> e)</span> </span>{<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">0</span> &amp;&amp; c == <span class="hljs-number">0</span> &amp;&amp; d == <span class="hljs-number">0</span> &amp;&amp; e == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> d = b - a;<br>    <span class="hljs-keyword">if</span> (b + d == c &amp;&amp; c + d == d &amp;&amp; d + d == e) {<br>        cout &lt;&lt; e + d &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e + <span class="hljs-number">2</span> * d &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e + <span class="hljs-number">3</span> * d<br>            &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e + <span class="hljs-number">4</span> * d &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; e + <span class="hljs-number">5</span> * d &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span> (a != <span class="hljs-number">0</span> &amp;&amp; b != <span class="hljs-number">0</span> &amp;&amp; c != <span class="hljs-number">0</span> &amp;&amp; d != <span class="hljs-number">0</span> &amp;&amp; e != <span class="hljs-number">0</span>) {<br>        <span class="hljs-type">int</span> q = b / a;<br>        <span class="hljs-keyword">if</span> (a * q == b &amp;&amp; b * q == c &amp;&amp; c * q == d &amp;&amp; d * q == e) {<br>            <span class="hljs-type">int</span> next = e;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) {<br>                next *= q;<br>                cout &lt;&lt; next &lt;&lt; <span class="hljs-string">" "</span>;<br>            }<br>            cout &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (a + b == c &amp;&amp; b + c == d &amp;&amp; c + d == e) {<br>        <span class="hljs-type">int</span> x = d, y = e;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) {<br>            <span class="hljs-type">int</span> z = x + y;<br>            cout &lt;&lt; z &lt;&lt; <span class="hljs-string">" "</span>;<br>            x = y;<br>            y = z;<br>        }<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-type">int</span> x = d, y = e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) {<br>        <span class="hljs-type">int</span> z = x + y;<br>        cout &lt;&lt; z &lt;&lt; <span class="hljs-string">" "</span>;<br>        x = y;<br>        y = z;<br>    }<br>    cout &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> a, b, c, d, e;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e) {<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">0</span> &amp;&amp; c == <span class="hljs-number">0</span> &amp;&amp; d == <span class="hljs-number">0</span> &amp;&amp; e == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">predictNext</span>(a, b, c, d, e);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="D题：复原二叉树">D题：复原二叉树</h2><h4 id="题目描述-v4">题目描述</h4><p>小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。</p><h4 id="输入-v4">输入</h4><p>输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。</p><h4 id="输出-v4">输出</h4><p>对于每组输入，输出对应的二叉树的后续遍历结果。</p><h4 id="样例输入-v4">样例输入</h4><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DBACEGF ABCDEFG</span><br><span class="hljs-attribute">BCAD CBAD</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v4">样例输出</h4><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ACBFGED</span><br><span class="hljs-attribute">CDAB</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v3">问题分析</h4><p>题目给前序和中序求后序遍历结果，前序是根左右（NLR），中序是左根右（LNR），也就是说前序遍历的第一个字母是二叉树的根节点，在中序遍历根节点前面的是根的左子树，后面的是右子树，这样我们可以不断找到树的前序遍历和中序遍历结果，从而进行递归。</p><h4 id="完整代码-v4">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(string pre, string in)</span> </span>{<br><span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">char</span> root;<br>root = pre[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> position;<br>position = in.<span class="hljs-built_in">find</span>(root);<br><span class="hljs-built_in">postOrder</span>(pre.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, position), in.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, position));<br><span class="hljs-built_in">postOrder</span>(pre.<span class="hljs-built_in">substr</span>(position + <span class="hljs-number">1</span>), in.<span class="hljs-built_in">substr</span>(position + <span class="hljs-number">1</span>));<br>cout &lt;&lt; root;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>string pre, in;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; pre &gt;&gt; in) {<br><span class="hljs-built_in">postOrder</span>(pre, in);<br>cout &lt;&lt; endl;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="E题：子树的后序遍历">E题：子树的后序遍历</h2><h4 id="题目描述-v5">题目描述</h4><p>给你一颗二叉树的中序和后序遍历序列，请编程输出该二叉树左子树或右子树的后序遍历序列。</p><h4 id="输入-v5">输入</h4><p>占三行，第一行表示二叉树的中序遍历序列，第二行表示后序遍历序列。用大写字母标识结点，二叉树的结点最多26个。<br>第三行是单个字母，L表示要求输出该二叉树的左子树的后序遍历序列，R表示要求输出该二叉树的右子树的后序遍历序列。</p><h4 id="输出-v5">输出</h4><p>按要求输出该二叉树左子树或右子树的后序遍历序列。</p><h4 id="样例输入-v5">样例输入</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">BDCEAFHG<br>DECBHGFA<br><span class="hljs-attribute">R</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v5">样例输出</h4><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">HGF</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v4">问题分析</h4><p>题目给中序和后序遍历，中序是左根右（LNR），后序是左右根（LRN），后序遍历的最后一个即为二叉树的根结点，从而在中序遍历中，根结点前面的是的左子树，后面的是右子树；由于本题输出后序遍历结果，而后序遍历结果题目已经给出，现只需计算左、右子树长度，从后序遍历中提取相应字符串长度即可。</p><h4 id="完整代码-v5">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>string in, post;<br>cin &gt;&gt; in &gt;&gt; post;<br><span class="hljs-type">char</span> side, root;<br>cin &gt;&gt; side;<br>root=post.<span class="hljs-built_in">back</span>();<span class="hljs-comment">// 后序最后一个字符是根节点</span><br><span class="hljs-type">int</span> position = in.<span class="hljs-built_in">find</span>(root);<br><span class="hljs-type">int</span> length;<br><span class="hljs-keyword">if</span> (side == <span class="hljs-string">'R'</span>) { <br>length = in.<span class="hljs-built_in">size</span>() - position - <span class="hljs-number">1</span>;<br>cout &lt;&lt; post.<span class="hljs-built_in">substr</span>(post.<span class="hljs-built_in">size</span>() - length - <span class="hljs-number">1</span>,length) &lt;&lt; endl; }<br><span class="hljs-keyword">else</span> { <br>length = position;<br>cout &lt;&lt; post.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,length); }<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="注意">注意</h4><ol><li>提取字符串最后一个字符时用 <code>post.back()</code>或<code>post[post.size() - 1]</code><br>获取最后一个字符（而不是 <code>post[-1]</code>，C++不支持负数索引）。</li><li>有关字符串<code>string</code>的函数：</li></ol><table><thead><tr><th>用法示例</th><th>作用</th><th>注意事项</th></tr></thead><tbody><tr><td><code>str.find()</code></td><td>查找字符或子串</td><td>返回首次出现字符的位置（size_t）</td></tr><tr><td><code>str.substr()</code></td><td>提取字符串</td><td>参数1：起始位置；参数2：长度（可选）</td></tr><tr><td><code>str.size()</code></td><td>获取字符串长度</td><td>返回字符数量（size_t）</td></tr><tr><td><code>str.empty()</code></td><td>判断是否为空</td><td>返回值bool类型</td></tr><tr><td><code>str.front()</code></td><td>获取首字符</td><td>返回char引用</td></tr><tr><td><code>str.back()</code></td><td>获取末尾字符</td><td>返回char引用</td></tr></tbody></table><h2 id="F题：迷宫问题">F题：迷宫问题</h2><h4 id="题目描述-v6">题目描述</h4><p>小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。<br>小明只能向上下左右四个方向移动。</p><h4 id="输入-v6">输入</h4><p>输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。<br>每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。<br>接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。<br>字符的含义如下：<br>‘S’：起点<br>‘E’：终点<br>‘-’：空地，可以通过<br>‘#’：障碍，无法通过<br>输入数据保证有且仅有一个起点和终点。</p><h4 id="输出-v6">输出</h4><p>对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。</p><h4 id="样例输入-v6">样例输入</h4><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1<br>5 5<br><span class="hljs-section">S-###</span><br><span class="hljs-section">-----</span><br>##---<br>E#---<br>---##<br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v6">样例输出</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></tbody></table></figure><h4 id="完整代码-v6">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100</span>;<br><span class="hljs-type">char</span> grid[MAX][MAX];<br><span class="hljs-type">int</span> dist[MAX][MAX];<br><span class="hljs-type">int</span> dx[] = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>};<br><span class="hljs-type">int</span> dy[] = {<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; start, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; end)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    dist[start.first][start.second] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-keyword">auto</span> [x, y] = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (x == end.first &amp;&amp; y == end.second)<br>            <span class="hljs-keyword">return</span> dist[x][y];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nx = x + dx[i], ny = y + dy[i];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m &amp;&amp; grid[nx][ny] != <span class="hljs-string">'#'</span> &amp;&amp; dist[nx][ny] == <span class="hljs-number">-1</span>) {<br>                dist[nx][ny] = dist[x][y] + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>({nx, ny});<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) {<br>        cin &gt;&gt; n &gt;&gt; m;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; start, end;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>                cin &gt;&gt; grid[i][j];<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'S'</span>) start = {i, j};<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'E'</span>) end = {i, j};<br>            }<br>        }<br><br>        <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dist));<br>        cout &lt;&lt; <span class="hljs-built_in">bfs</span>(start, end) &lt;&lt; <span class="hljs-string">'\n'</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stack</tag>
      
      <tag>binary tree</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUMT-Datastructure-Practice 2</title>
    <link href="/2025/06/18/Data%20structure/CUMT-Datastructure-Practice-2/"/>
    <url>/2025/06/18/Data%20structure/CUMT-Datastructure-Practice-2/</url>
    
    <content type="html"><![CDATA[<p><strong>数据结构实验2，涉及无向图的深度优先搜索问题问二叉树构建最小堆问题、折半查找和简单排序问题，包含重要知识点的解析、解题思路和完整代码。</strong></p> <span id="more"></span><h2 id="A题：无向图的深度优先搜索">A题：无向图的深度优先搜索</h2><h4 id="题目描述">题目描述</h4><p>已知一个无向图G的顶点和边，顶点从0依次编号，现在需要深度优先搜索，访问任一邻接顶点时编号小的顶点优先，请编程输出图G的深度优先搜索序列。</p><h4 id="输入">输入</h4><p>第一行是整数m和n（1&lt;m,n&lt;100），分别代表顶点数和边数。后边n行，每行2个数，分别表示一个边的两个顶点。</p><h4 id="输出">输出</h4><p>该图从0号顶点开始的深度优先搜索序列。</p><h4 id="样例输入">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析">问题分析</h4><p>使用邻接表存储图结构，读取数据后，为了保证小编号顶点优先访问，使用<code>sort()</code>将每个邻接表中的数据升序排列，函数调用中使用栈实现非递归DFS：<br>将<code>start</code>压入栈内，若有邻接的顶点未被访问，将其输出，使用<code>visited</code>数组记录访问过的顶点并将其压入栈内；若其邻接的顶点均被访问，则回溯，弹出栈顶元素。</p><h4 id="完整代码">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//sort()函数的调用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//深度优先搜索DFS函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt; visited, <span class="hljs-type">int</span> start)</span> </span>{<br>stack&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">push</span>(start);<span class="hljs-comment">//将起始点压入栈内</span><br>visited[start] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记起始点已访问</span><br>cout &lt;&lt; start &lt;&lt; <span class="hljs-string">" "</span>;<br><br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) {<br><span class="hljs-type">int</span> current = s.<span class="hljs-built_in">top</span>();<br><span class="hljs-type">bool</span> found = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor:graph[current]) {<br><span class="hljs-keyword">if</span> (!visited[neighbor]) {<span class="hljs-comment">//如果邻接顶点未被访问</span><br>visited[neighbor] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记为已访问</span><br>cout &lt;&lt; neighbor &lt;&lt; <span class="hljs-string">" "</span>;<br>s.<span class="hljs-built_in">push</span>(neighbor);<span class="hljs-comment">//将该顶点压入栈内</span><br>found = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记已访问过的顶点</span><br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出循环，优先处理该顶点的邻接顶点</span><br>}<br>}<br><span class="hljs-keyword">if</span> (!found) {<span class="hljs-comment">//若果该顶点没有未被访问的邻接顶点</span><br>s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//弹出栈顶元素，回溯</span><br>}<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> m, n;<br>cin &gt;&gt; m &gt;&gt; n;<span class="hljs-comment">//读入定点数和边数</span><br><span class="hljs-type">int</span> a, b;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(m);<br><span class="hljs-comment">//初始化邻接表，大小为m，每个元素是vector&lt;int&gt;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br>cin &gt;&gt; a &gt;&gt; b;<br>graph[a].<span class="hljs-built_in">push_back</span>(b);<br>graph[b].<span class="hljs-built_in">push_back</span>(a);<br><span class="hljs-comment">//用读入的数据构建邻接表，注意两边都要处理</span><br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) {<br><span class="hljs-built_in">sort</span>(graph[i].<span class="hljs-built_in">begin</span>(), graph[i].<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//对每个邻接表进行排序，确保DFS优先访问编号小的元素</span><br>}<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(m, <span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-comment">//初始化访问标记数组，大小为m，初始值为false（未被访问状态）</span><br><span class="hljs-built_in">DFS</span>(graph, visited, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="注释">注释</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph<br></code></pre></td></tr></tbody></table></figure><p>相当于一个<code>graph[][]</code>的二维数组，外层的<code>vector</code>存储所有的顶点，内层的<code>vector&lt;int&gt;</code>存储每个顶点的邻接顶点列表</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor:graph[current])<br></code></pre></td></tr></tbody></table></figure><p>这是C++11 引入了范围<code>for</code>循环语法，专门用于遍历容器（如 <code>vector</code>、<code>list</code>等），每次循环时变量会自动依次选取容器中的下一个元素。（注意中间是<code>:</code>）</p><h2 id="B题：最小堆的形成">B题：最小堆的形成</h2><h4 id="题目描述-v2">题目描述</h4><p>现在给你n个结点的完全二叉树数组存储序列，请编程调整为最小堆，并输出相应最小堆的存储序列。</p><h4 id="输入-v2">输入</h4><p>第一行是n，第二行是n个结点的完全二叉树数组存储序列。</p><h4 id="输出-v2">输出</h4><p>输出相应最小堆的存储序列。</p><h4 id="样例输入-v2">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">53 </span><span class="hljs-number">17</span> <span class="hljs-number">78</span> <span class="hljs-number">23</span> <span class="hljs-number">45</span> <span class="hljs-number">65</span> <span class="hljs-number">87</span> <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v2">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">17</span> <span class="hljs-number">65</span> <span class="hljs-number">23</span> <span class="hljs-number">45</span> <span class="hljs-number">78</span> <span class="hljs-number">87</span> <span class="hljs-number">53</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v2">问题分析</h4><p>解决问题前首先要了解什么是完全二叉树、什么是最小堆以及完全二叉树有什么性质。<strong>完全二叉树</strong>就是除了最后一层外，其他层的节点都是满的，并且最后一层的节点都尽可能靠左排列的二叉树（从上到下、从左到右的顺序进行填充）。<strong>最小堆</strong>就是满足节点的值&lt;=其子叶节点的值的完全二叉树（给定完全二叉树求最小堆时不可直接升序排列，其有特定的存储结构）。<br>假设完全二叉树某节点编号为<code>i</code>,则其父节点为<code>i/2</code>，其左子叶节点为<code>2*i</code>，其右子叶节点为<code>2*i+1</code>。而对于最小堆，其根节点为其全局最小值。有了这些简单的前置知识我们就可以开始解决这道题目了。<br>由于<strong>下沉法</strong>相对于<strong>上浮法</strong>具有更高的效率，因此本题先选择自底向上的下沉法递归求解。</p><h4 id="完整代码-v2">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; tree, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> parent)</span> </span>{<br><span class="hljs-comment">//完全二叉树的性质</span><br><span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * parent;<span class="hljs-comment">//左子叶节点</span><br><span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<span class="hljs-comment">//右子叶节点</span><br><span class="hljs-type">int</span> smallest = parent;<span class="hljs-comment">//初始化最小值为顶点</span><br><span class="hljs-keyword">if</span> (left &lt;= n &amp;&amp; tree[left] &lt; tree[smallest]) {<br>smallest = left;<br>}<br><span class="hljs-keyword">if</span> (right &lt;= n &amp;&amp; tree[right] &lt; tree[smallest]) {<br>smallest = right;<br>}<span class="hljs-comment">//找出三个节点中的最小值，将其交换至父节点</span><br>    <span class="hljs-keyword">if</span>(smallest!=parent){<br><span class="hljs-type">int</span> temp = tree[smallest]; <br>tree[smallest] = tree[parent];<br>tree[parent] = temp;<br><span class="hljs-comment">//交换 也可以使用swap()更简便</span><br><span class="hljs-built_in">down</span>(tree, n, smallest);<br><span class="hljs-comment">//由于最小值上移，原位置需要递归重新确保其子树为最小堆</span><br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">tree</span>(n<span class="hljs-number">+1</span>);<br><span class="hljs-comment">//提前为tree分配空间为n+1</span><br>    <span class="hljs-comment">//（由于从1开始索引）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) {<br>cin &gt;&gt; tree[i];<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>;i &gt;= <span class="hljs-number">1</span>;i--){<br><span class="hljs-built_in">down</span>(tree, n, i);<br>}<br><span class="hljs-comment">//从最小的非子叶结点开始递归</span><br><span class="hljs-comment">//反向遍历，确保处理父节点是，其子树已是最小堆结构</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++){<br>cout &lt;&lt; tree[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="C题：折半查找次数">C题：折半查找次数</h2><h4 id="题目描述-v3">题目描述</h4><p>给你一个无重复数的有序序列，如果采用折半查找的方式，对于给定的数，需要比较几次找到，请编程实现。</p><h4 id="输入-v3">输入</h4><p>第一行是N，表示序列中数的个数，序列最长1000，第二行是一个有序序列，第三行是要找的数x。</p><h4 id="输出-v3">输出</h4><p>如果找到x，输出折半比较的次数，否则输出NO。</p><h4 id="样例输入-v3">样例输入</h4><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">11</span><br><span class="hljs-attribute">5</span> <span class="hljs-number">13</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span> <span class="hljs-number">37</span> <span class="hljs-number">56</span> <span class="hljs-number">64</span> <span class="hljs-number">75</span> <span class="hljs-number">80</span> <span class="hljs-number">88</span> <span class="hljs-number">92</span><br><span class="hljs-attribute">19</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v3">样例输出</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></tbody></table></figure><h4 id="完整代码-v3">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        cin &gt;&gt; arr[i];<br>    }<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> found = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) {<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        cnt++; <br>        <span class="hljs-keyword">if</span> (arr[mid] == x) {<br>            found = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; x) {<br>            low = mid + <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">else</span> {<br>            high = mid - <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (found)<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="D题：N个数的排序">D题：N个数的排序</h2><h4 id="题目描述-v4">题目描述</h4><p>给你N个自然数，编程输出排序后的这N个数。</p><h4 id="输入-v4">输入</h4><p>第一行是整数的个数N（N&lt;=100）。第二行是用空格隔开的N个数。</p><h4 id="输出-v4">输出</h4><p>排序输出N个数，每个数间用一个空格间隔。</p><h4 id="样例输入-v4">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v4">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v3">问题分析</h4><p>本题是最基础的的排序问题，这里采用冒泡排序、选择排序、c++封装的<code>sort()</code>排序函数三种方法进行求解。</p><h4 id="完整代码-v4">完整代码</h4><p>冒泡排序算法求解：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubblesort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>{<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n - i - <span class="hljs-number">1</span>;j++) {<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>}<br>}<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>], n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br>cin &gt;&gt; arr[i];<br>}<br><span class="hljs-built_in">bubblesort</span>(arr, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>选择排序算法求解：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectsort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (begin &lt; n) {<br>        <span class="hljs-type">int</span> min = INT_MAX; <br>        <span class="hljs-type">int</span> tag = begin; <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin; i &lt; n; i++) {<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; min) {<br>                tag = i;<br>                min = arr[tag];<br>            }<br>        }<br>        <span class="hljs-type">int</span> temp = arr[begin];<br>        arr[begin] = arr[tag];<br>        arr[tag] = temp;<br>        begin++; <br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>], n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br>cin &gt;&gt; arr[i];<br>}<br><span class="hljs-built_in">selectsort</span>(arr, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>STL封装的 <code>sort()</code>排序函数求解：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>vector &lt;<span class="hljs-type">int</span>&gt; arr;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br><span class="hljs-type">int</span> a;<br>cin &gt;&gt; a;<br>arr.<span class="hljs-built_in">push_back</span>(a);<br>}<br><span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) {<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>封面来源：<a href="https://www.youtube.com/watch?v=Etpc_-br5rI&amp;t=21s">Tree data structures in 2 minutes</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>binary tree</tag>
      
      <tag>DFS</tag>
      
      <tag>search，graph，sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUMT-Datastructure-Assignment 1</title>
    <link href="/2025/06/08/Data%20structure/CUMT-Datastructure-Assignment-1/"/>
    <url>/2025/06/08/Data%20structure/CUMT-Datastructure-Assignment-1/</url>
    
    <content type="html"><![CDATA[<p><strong>数据结构作业1，涉及循环链表的约瑟夫问题和栈相关的问题，包含重要知识点的解析、解题思路和完整代码。</strong></p> <span id="more"></span><h2 id="E题：-约瑟夫问题">E题： 约瑟夫问题</h2><h4 id="题目描述">题目描述</h4><p>编写一个程序求解约瑟夫（Joseph）问题。有n个小孩围成一圈，给他们从1开始依次编号，从编号为1的小孩开始报数，数到第m（0&lt;m&lt;n）个小孩出列，然后从出列的下一个小孩重新开始报数，数到第m个小孩又出列，…，如此反复直到所有的小孩全部出列为止，求整个出列序列。</p><h4 id="输入">输入</h4><p>占一行为n和m（n&lt;100）。</p><h4 id="输出">输出</h4><p>整个出列序列。</p><h4 id="样例输入">样例输入</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析">问题分析</h4><p>约瑟夫问题是一个经典的使用循环链表的问题，<strong>解题思路</strong>如下：</p><ol><li>创建循环链表：通过结构体<code>struct</code>创建孩子结点，创建<code>head</code>头结点和指向当前结点可供遍历进行移动的指针<code>cur</code>，再通过<code>for</code>循环遍历，用<code>new</code>运算动态分配内存，给每个孩子结点的<code>num</code>域赋上编号的初值，最后将尾结点的指针域指向头结点，完成链表的闭合，实现循环链表的功能。</li><li>模拟报数过程：通过<code>cur</code>指针，计数<code>m-1</code>个孩子后，<code>delete</code>删除下一个结点释放内存。</li><li>重复过程：重复执行，直至有<code>cur==cur-&gt;next</code>时，即链表中只剩下一个孩子时终止遍历。</li></ol><h4 id="完整代码">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//定义孩子结点的结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Child</span>{<br><span class="hljs-type">int</span> num;<span class="hljs-comment">//孩子编号</span><br>Child* next;<span class="hljs-comment">//指向下一个孩子的指针</span><br>};<br><span class="hljs-comment">//约瑟夫问题解决主函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Joseph</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m)</span> </span>{<br>Child* head = <span class="hljs-keyword">new</span> Child;<span class="hljs-comment">//创建第一个孩子的头结点</span><br>head-&gt;num = <span class="hljs-number">1</span>;<span class="hljs-comment">//头结点的编号</span><br>   head-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//定义头结点的指针为空</span><br>Child* cur = head;<span class="hljs-comment">//当前指针指向头结点</span><br><span class="hljs-comment">//构建循环链表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) {<br>Child* node = <span class="hljs-keyword">new</span> Child;<span class="hljs-comment">//创建后续新的孩子结点</span><br>node-&gt;num = i;<span class="hljs-comment">//给后续孩子孩子结点编号</span><br>cur-&gt;next = node;<span class="hljs-comment">//指针指向新的结点</span><br>cur = cur-&gt;next;<span class="hljs-comment">//指针向后移动</span><br>}<span class="hljs-comment">//链表构建完成</span><br>cur-&gt;next = head;<span class="hljs-comment">//将链表首尾相接形成循环</span><br><span class="hljs-keyword">while</span> (cur != cur-&gt;next) {<span class="hljs-comment">//当剩下的孩子不止一个时</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++) {<span class="hljs-comment">//数m-1个孩子</span><br>cur = cur-&gt;next;<br>}<br>Child* victim = cur-&gt;next;<span class="hljs-comment">//用新的victim记录删除的节点</span><br>cout &lt;&lt; victim-&gt;num &lt;&lt; <span class="hljs-string">" "</span>;<br>cur-&gt;next = victim-&gt;next;<span class="hljs-comment">//跳过第m个结点，指针域进行连接</span><br><span class="hljs-keyword">delete</span> victim;<span class="hljs-comment">//释放内存</span><br>}<br>cout &lt;&lt; cur-&gt;num &lt;&lt; <span class="hljs-string">" "</span>;<br><span class="hljs-keyword">delete</span> cur;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">//执行主函数</span><br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-built_in">Joseph</span>(n, m);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="F题：括号配对">F题：括号配对</h2><h4 id="题目描述-v2">题目描述</h4><p>设计一个算法利用顺序栈检查用户输入的表达式中括号是否配对（假设表达式中可能含有圆括号()、中括号[]和大括号{}）。</p><h4 id="输入-v2">输入</h4><p>占一行为含有三种括号的表达式（最长100个符号）。</p><h4 id="输出-v2">输出</h4><p>匹配时输出YES，小括号不匹配输出NO1，中括号不匹配时输出NO2，大括号不匹配时输出NO3。</p><h4 id="样例输入-v2">样例输入</h4><figure class="highlight clojure"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">{([a])}<br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v2">样例输出</h4><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">YES</span><br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v2">问题分析</h4><p>栈"后进先出"(LIFO)的特性正好匹配括号嵌套的顺序，<strong>解题思路</strong>如下：</p><ol><li>如果检测输入为左括号，压入栈中；如果检测输入为右括号：检测栈是否为空、如果相匹配则弹出栈，不匹配则输出错误。</li></ol><h4 id="注意点">注意点</h4><ol><li>执行有关栈的操作，如<code>.top()</code>、<code>.pop()</code>时，需要先检查栈非空，否则会导致未定义行为。输入遍历结束后也需要检查是否非空。</li><li>需要考虑输入的特殊情况，如只有左、右括号，左括号多余，无输入的情况。</li><li>根据左括号是否匹配进行输出NO，而不是根据右括号匹配判断。</li><li>注意处理当输入字符为非括号时的情况。</li></ol><h4 id="完整代码-v2">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">char</span> a;<br>    stack&lt;<span class="hljs-type">char</span>&gt; match;<span class="hljs-comment">//用于存储左括号的栈</span><br>    <span class="hljs-type">bool</span> hasInput = <span class="hljs-literal">false</span>;<span class="hljs-comment">//标记是否有输入</span><br><br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a) {<br>        hasInput = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-string">'('</span> || a == <span class="hljs-string">'['</span> || a == <span class="hljs-string">'{'</span>) {<br>            match.<span class="hljs-built_in">push</span>(a);<br>        }<span class="hljs-comment">//处理左括号，输入后压进栈内</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-string">')'</span> || a == <span class="hljs-string">']'</span> || a == <span class="hljs-string">'}'</span>) {<br>            <span class="hljs-keyword">if</span> (match.<span class="hljs-built_in">empty</span>()) {<br>                <span class="hljs-keyword">if</span> (a == <span class="hljs-string">')'</span>) cout &lt;&lt; <span class="hljs-string">"NO1"</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-string">']'</span>) cout &lt;&lt; <span class="hljs-string">"NO2"</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-string">'}'</span>) cout &lt;&lt; <span class="hljs-string">"NO3"</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            }<br>            <span class="hljs-type">char</span> top = match.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//查看栈顶元素</span><br>            <span class="hljs-keyword">if</span> ((a == <span class="hljs-string">')'</span> &amp;&amp; top == <span class="hljs-string">'('</span>) ||<br>                (a == <span class="hljs-string">']'</span> &amp;&amp; top == <span class="hljs-string">'['</span>) ||<br>                (a == <span class="hljs-string">'}'</span> &amp;&amp; top == <span class="hljs-string">'{'</span>)) {<br>                match.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//匹配则弹出栈顶</span><br>            }<br>            <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">if</span> (top == <span class="hljs-string">'('</span>) cout &lt;&lt; <span class="hljs-string">"NO1"</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top == <span class="hljs-string">'['</span>) cout &lt;&lt; <span class="hljs-string">"NO2"</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top == <span class="hljs-string">'{'</span>) cout &lt;&lt; <span class="hljs-string">"NO3"</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (!hasInput) {<br>        cout &lt;&lt; <span class="hljs-string">"YES"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (match.<span class="hljs-built_in">empty</span>()) {<br>        cout &lt;&lt; <span class="hljs-string">"YES"</span> &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">else</span> {<br>        <span class="hljs-type">char</span> top = match.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (top == <span class="hljs-string">'('</span>) cout &lt;&lt; <span class="hljs-string">"NO1"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top == <span class="hljs-string">'['</span>) cout &lt;&lt; <span class="hljs-string">"NO2"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top == <span class="hljs-string">'{'</span>) cout &lt;&lt; <span class="hljs-string">"NO3"</span> &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="G题：后缀表达式">G题：后缀表达式</h2><h4 id="题目描述-v3">题目描述</h4><p>给出一个中缀表达式，输出该表达式的后缀表达式。</p><h4 id="输入-v3">输入</h4><p>占一行，一个中缀表达式（运算符只有+ - * /，最多1000个字符），输出后缀表达式。</p><h4 id="输出-v3">输出</h4><p>输出后缀表达式。</p><h4 id="样例输入-v3">样例输入</h4><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-number">56</span><span class="hljs-number">-20</span>)/(<span class="hljs-number">4</span><span class="hljs-number">+2</span>)<br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v3">样例输出</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">56 </span><span class="hljs-number">20</span> - <span class="hljs-number">4</span> <span class="hljs-number">2</span> + /<br></code></pre></td></tr></tbody></table></figure><h4 id="问题分析-v3">问题分析</h4><p>本题也是栈的经典问题，<strong>解题思路</strong>如下：</p><ol><li>根据先乘除后加减的原则，数字划分优先级</li><li>当读入的输入时数字时，直接将其输出，若读入的是运算符，则先检查栈内：栈空，则压入栈内；栈非空，则与栈顶元素比较：将栈中优先级不低于当前运算符的运算符弹出并输出，然后将当前运算符入栈</li></ol><h4 id="注意点-v2">注意点</h4><ol><li>遇到左括号时直接入栈，遇到右括号时，不断弹出栈顶运算符并输出，直到遇到左括号（左括号弹出但不输出）</li><li>表达式扫描完毕后，将栈中剩余运算符全部弹出并输出</li></ol><h4 id="完整代码-v3">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//定义运算符优先级函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>{<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'+'</span> || ch == <span class="hljs-string">'-'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'*'</span> || ch == <span class="hljs-string">'/'</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    stack&lt;<span class="hljs-type">char</span>&gt; cal;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-type">bool</span> read = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; noskipws &gt;&gt; ch) { <span class="hljs-comment">//不跳过空格读入</span><br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span> || ch == <span class="hljs-string">'\n'</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(ch)) {<span class="hljs-comment">//如果是数字</span><br>            cout &lt;&lt; ch;<br>            read = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记读入的是数字</span><br>        }<br>        <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">if</span> (read) {<br>                cout &lt;&lt; <span class="hljs-string">" "</span>;<br>                read = <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'('</span>) {<span class="hljs-comment">//左括号直接入栈</span><br>                cal.<span class="hljs-built_in">push</span>(ch);<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">')'</span>) {<span class="hljs-comment">//处理读入的右括号</span><br>            <span class="hljs-comment">//弹出栈顶元素直至栈顶为左括号</span><br>                <span class="hljs-keyword">while</span> (!cal.<span class="hljs-built_in">empty</span>() &amp;&amp; cal.<span class="hljs-built_in">top</span>() != <span class="hljs-string">'('</span>) {<br>                    cout &lt;&lt; cal.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">" "</span>;<br>                    cal.<span class="hljs-built_in">pop</span>();<br>                }<br>                <span class="hljs-keyword">if</span> (!cal.<span class="hljs-built_in">empty</span>()) cal.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//弹出左括号但不输出</span><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'+'</span> || ch == <span class="hljs-string">'-'</span> || ch == <span class="hljs-string">'*'</span> || ch == <span class="hljs-string">'/'</span>) {<br>                <span class="hljs-keyword">while</span> (!cal.<span class="hljs-built_in">empty</span>() &amp;&amp; cal.<span class="hljs-built_in">top</span>() != <span class="hljs-string">'('</span> &amp;&amp; <span class="hljs-built_in">pre</span>(cal.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">pre</span>(ch)) {<br>                    cout &lt;&lt; cal.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">" "</span>;<br>                    cal.<span class="hljs-built_in">pop</span>();<br>                }<br>                cal.<span class="hljs-built_in">push</span>(ch);<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">//弹出栈内所有运算符</span><br>    <span class="hljs-keyword">while</span> (!cal.<span class="hljs-built_in">empty</span>()) {<br>        cout &lt;&lt; cal.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">" "</span>;<br>        cal.<span class="hljs-built_in">pop</span>();<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="注释">注释</h4><p><code>&lt;cctype&gt;</code> 是 C++ 标准库中的头文件，提供了一系列用于字符分类和处理的函数（通常传入的参数类型为 <code>char</code>）。</p><table><thead><tr><th>字符分类函数</th><th>作用</th></tr></thead><tbody><tr><td><code>isalpha()</code></td><td>检查是否是字母（a-z, A-Z）</td></tr><tr><td><code>isdigit()</code></td><td>检查是否是数字（0-9）</td></tr><tr><td><code>isalnum()</code></td><td>检查是否是字母或数字</td></tr><tr><td><code>isspace()</code></td><td>检查是否是空白字符（空格、制表符、换行等）</td></tr><tr><td><code>islower()</code></td><td>检查是否是小写字母</td></tr><tr><td><code>isupper()</code></td><td>检查是否是大写字母</td></tr></tbody></table><table><thead><tr><th>字符转换函数</th><th>作用</th></tr></thead><tbody><tr><td><code>tolower()</code></td><td>将字符转换为小写</td></tr><tr><td><code>toupper()</code></td><td>将字符转换为大写</td></tr></tbody></table><p><code>noskipws</code>是定义在 <code>&lt;iomanip&gt;</code>头文件中的一个 I/O 操纵符（manipulator），全称是 <strong>“no skip whitespace”</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> ch;<br>cin &gt;&gt; ch;       <span class="hljs-comment">// 自动跳过空白，读取第一个非空白字符</span><br>cin &gt;&gt; noskipws &gt;&gt; ch;  <span class="hljs-comment">// 不跳过空白，读取下一个字符（可能是空白）</span><br></code></pre></td></tr></tbody></table></figure><p>如果需要恢复默认的跳过空白行为（作用相当于一个开关激活函数）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; noskipws;  <span class="hljs-comment">// 关闭跳过空白</span><br><span class="hljs-comment">// ... 读取包含空格的输入 ...</span><br>cin &gt;&gt; skipws;    <span class="hljs-comment">// 恢复默认行为</span><br></code></pre></td></tr></tbody></table></figure><p>与<code>cin.get</code>相比更加灵活可控：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin.<span class="hljs-built_in">get</span>(ch);  <span class="hljs-comment">// 总是读取下一个字符（包括空白），不需要 noskipws</span><br></code></pre></td></tr></tbody></table></figure><h2 id="H题：字符串反转">H题：字符串反转</h2><h4 id="题目描述-v4">题目描述</h4><p>小C很喜欢倒着写单词，现在给你一行小C写的文本，你能把每个单词都反转并输出它们吗？</p><h4 id="输入-v4">输入</h4><p>输入包含多组测试样例。第一行为一个整数T，代表测试样例的数量，后面跟着T个测试样例。每个测试样例占一行，包含多个单词。一行最多有1000个字符。</p><h4 id="输出-v4">输出</h4><p>对于每一个测试样例，你应该输出转换后的文本。</p><h4 id="样例输入-v4">样例输入</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">3</span><br>olleh !dlrow<br><span class="hljs-selector-tag">I</span> ekil <span class="hljs-selector-class">.bulcmca</span><br><span class="hljs-selector-tag">I</span> evol <span class="hljs-selector-class">.mca</span><br></code></pre></td></tr></tbody></table></figure><h4 id="样例输出-v4">样例输出</h4><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hello world!<br><span class="hljs-selector-tag">I</span> like acmclub.<br><span class="hljs-selector-tag">I</span> love acm.<br></code></pre></td></tr></tbody></table></figure><h3 id="问题分析-v4">问题分析</h3><p>本题适合用栈“先进后出”的特性来进行字符串的反转，<strong>解题思路</strong>如下：</p><ol><li>逐个字符处理进行读入，压入栈内</li><li>当遇到空格时，将栈内的字符全部弹出</li><li>循环结束后单独处理栈内剩余元素</li></ol><h4 id="注意点-v3">注意点</h4><ol><li>是逐个单词进行逆序，不是整段文本所有字母的逆序，因此需要根据输入的空格和回车来确定分段点。</li></ol><h4 id="完整代码-v4">完整代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">()</span> </span>{<br>    string line;<br>    <span class="hljs-built_in">getline</span>(cin, line);<span class="hljs-comment">//整行读入输入</span><br>    stack&lt;<span class="hljs-type">char</span>&gt; st;<span class="hljs-comment">//用于反转字符的栈</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : line) {<span class="hljs-comment">//遍历每一个字符</span><br>    <span class="hljs-comment">//line可以是字符串也可以是字符数组</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">' '</span>) {<span class="hljs-comment">//遇到空格，开始输出字符</span><br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>                cout &lt;&lt; st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            }<br>            cout &lt;&lt; <span class="hljs-string">' '</span>;<br>        }<br>        <span class="hljs-keyword">else</span> {<br>            st.<span class="hljs-built_in">push</span>(c);<br>        }<br>    }<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<span class="hljs-comment">//循环结束，处理最后一个没有空格的单词</span><br>        cout &lt;&lt; st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>    }<br>    cout &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    cin.<span class="hljs-built_in">ignore</span>(); <span class="hljs-comment">//忽略换行符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-built_in">reverseWords</span>();<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="注释-v2">注释</h4><table><thead><tr><th>特性</th><th>getline(cin, line)</th><th>cin.get()</th></tr></thead><tbody><tr><td>读取方式</td><td>读取整行直到’\n’</td><td>可读取单个字符或一行</td></tr><tr><td>存储类型</td><td><code>string</code></td><td><code>char</code>或<code>char[]</code></td></tr><tr><td>是否跳过空白字符</td><td>不会跳过（读取所有字符）</td><td>不会跳过（读取所有字符）</td></tr><tr><td>换行符处理</td><td>丢弃’\n’（不存储）</td><td>可以读取’\n’</td></tr></tbody></table><p>封面来源：<a href="https://www.youtube.com/watch?v=DuDz6B4cqVc&amp;t=92s">Data Structures: Crash Course Computer Science #14</a></p>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linear List，stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Me and My Blog</title>
    <link href="/2025/06/04/other/About%20Me%20and%20My%20Blog/"/>
    <url>/2025/06/04/other/About%20Me%20and%20My%20Blog/</url>
    
    <content type="html"><![CDATA[<p><strong>Brief Self-Introduction and the Motivation Behind Deploying My Blog!!!</strong> 😄</p> <span id="more"></span><h2 id="Before-The-Blog">Before The Blog</h2><p>  从高中到大学，我一直保持着系统化记笔记的学习习惯。然而，计算机专业的独特性让我一度感到不适应——知识的海洋如此浩瀚，技术栈的广度令人惊叹，传统的应试学习方法在这里显得捉襟见肘。</p><p>  机缘巧合之下我在牛客等招聘网站上看到优秀求职者的技术博客链接，又注意到同学在朋友圈分享的博客文章，相互交换博客链接，相互学习。这些见闻就像一粒种子，在我心中悄然生根发芽。</p><p>  但向来语文表达能力欠佳的我，对于博客撰写还是稍有抵触态度的，只是在CSDN上慢慢开始了尝试，逐渐发现在<strong>AI大模型</strong>语言润色写作的支持下，或许并不困难。甚至这种<strong>将知识咀嚼在二次消化的“反刍”过程</strong>，使我内心产生了巨大的<strong>成就感</strong>！</p><p>这里引用一下我的这位同学博客里的原话：</p><div class="note note-primary">            <p>  “无论是解题、写作，还是费曼学习法，其本质都是<strong>通过输出来强化知识</strong>的吸收。当你能够流畅地演绎一道数学题的多种解法，或是将庞杂的知识梳理成清晰的逻辑链条，甚至写成一篇能让读者受益的博客时，你便完成了<strong>从输入到输出</strong>的有效做功。而这一过程，不仅让知识真正内化，更赋予人莫大的成就感。”</p>          </div><div class="note note-primary">            <p>  “然而，写作——尤其是高质量的博客写作——远非简单的文字堆砌。回想高中写议论文时的经历，你是否也曾感到一种“言不尽意”的挫败？<strong>灵感的闪现 ≠ 逻辑的成型 ≠ 语言的表达 ≠ 理想的呈现</strong>。很多时候，我们脑海中的所谓“灵感”，不过是零星的思维火花，距离一篇结构严谨、论证充分、兼具深度与可读性的文章，仍有漫长的路要走。”</p>          </div><div class="note note-primary">            <p>  “而这，正是博客写作的真正挑战，也是它最珍贵的训练价值——<strong>如何将飘忽的灵感锤炼成扎实的文字，在逻辑与专业之间找到平衡，最终实现清晰而有力的表达。</strong>”</p>          </div><p>  在CSDN的简单试水中，我收获了莫大的自信，遂趁着期末周刚结束，全身心地投入到Github个人博客的创建中来！</p><p><img src="/images/About-Me-and-My-Blog/%E5%9B%BE%E7%89%871.png" alt="截止2025年7月13日CSDN状态图"></p><h2 id="About-Myself">About Myself</h2> <div class="note note-primary">            <p>I am <strong>Li Qinxuan (李沁轩)</strong>, a dedicated Computer Science and Technology scholar at <strong>China University of Mining and Technology (中国矿业大学)</strong>. My academic pursuits encompass diverse domains of computing, with specialized expertise and fervent enthusiasm for <strong>computer vision</strong> and <strong>algorithmic design</strong>.</p>          </div><div style="text-align: center;">  <strong style="color: red; font-size: 2em;">KEEP CODING!!!</strong></div><h3 id="My-Email">My Email</h3><ul><li><a href="mailto:lqx3222482537@qq.com">lqx3222482537@qq.com</a></li><li><a href="mailto:richardli.11.02.06@gmail.com">richardli.11.02.06@gmail.com</a></li><li><a href="mailto:08241120@cumt.edu.cn">08241120@cumt.edu.cn</a></li></ul><h3 id="My-Blog-in-CSDN">My Blog in CSDN</h3><p><a href="https://blog.csdn.net/2401_86849688?type=blog">不在了情绪的CSDN博客账号</a><br>(其实两边可能是同步更新的哈)</p><p>网站使用Github Pages 和 Hexo静态部署，fluid主题，相关链接地址如下：</p><ul><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">Hexo Fluid 用户手册</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev for hexo theme</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li></ul><p>如果大家有任何疑问，欢迎提issue，也欢迎通过邮箱联系我，我们一起进步！</p><h3 id="photos">photos</h3><ul><li>图片多从YouTube和<a href="https://unsplash.com/">unsplash</a>上获取</li><li>使用<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here">PicGo插件</a>和Github实现<strong>图床</strong>功能<br>不想折腾的可以看看这篇骚操作😀：<br><a href="https://blog.csdn.net/hotdog233/article/details/119380498?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E7%89%87%E7%9B%B4%E9%93%BE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119380498.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187">图片外链方法大全： 免费的图床！ 告别新浪图床 和 CDN</a></li></ul><p>封面来源：<a href="https://www.youtube.com/watch?v=GWGbOjlJDkU">Who are you?</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Motivation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Practical Guide to Writing Blogs！</title>
    <link href="/2025/05/29/Tutorial/Markdown%EF%BC%8CPractical%20Guide%20to%20Writing%20Blogs%EF%BC%81/"/>
    <url>/2025/05/29/Tutorial/Markdown%EF%BC%8CPractical%20Guide%20to%20Writing%20Blogs%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<h2 id="个人博客搭建指南：">个人博客搭建指南：</h2><p><strong>介绍markdown从入门到进阶的语法进行博客撰写</strong></p><span id="more"></span><p>  正所谓“工欲善其事必先利其器”，博主之前在csdn上写过一些简单，了解也使用过一些简单的markdown语法，但是最近新部署了github博客网站，发现别人的博客网站颜色华丽，排版精美，而我的博客却只有简单的标题、正文、斜体、加粗等简单的界面，煞是寡淡，于是上网学习，发现在markdown中可以添加HTML标签和CSS样式，使得界面变得更加丰富，更加美观，下面是一些markdown的基础语法和进阶玩法，希望对大家有所帮助。</p><h3 id="markdown语法">markdown语法</h3><p>  markdown语法具有简单易学的特性，但这也带来了一定的局限性，或许对于初学者来说是个不错的选择，但对于一些需要更加丰富的界面和功能、有更高追求的用户来说，可能需要使用HTML标签和CSS样式来实现更加复杂的界面和功能。</p><h3 id="HTML标签">HTML标签</h3><p>  HTML标签是用来描述网页内容的标签，通过HTML标签可以实现更加丰富的界面和功能，例如添加图片、视频、表格、链接等。</p><h3 id="CSS样式">CSS样式</h3><p>  CSS样式是用来描述网页样式的样式，通过CSS样式可以实现更加丰富的界面和功能，例如添加背景色、字体颜色、边框、圆角等。</p><h3 id="markdown语法和HTML标签">markdown语法和HTML标签</h3><p>  Markdown 自带的标记和 HTML 标签之间具有一定的互换性。事实上，Github 在展示 Markdown 格式的文件的时候，就是将 Markdown 的标记替换为 HTML 标签，再通过一定的方式渲染得到最终效果的。<br>  尽管 Markdown 脱胎于 HTML，但是它们之间依然存在显著的区别。HTML 侧重于渲染的效果，具有复杂且多样的标签和繁复的框架结构，而 Markdown 则更加关注文本内容，标记少而简单，内容以文本为主。显然，HTML 学习和编辑的难度更大，但是能获得更统一，更加标准化的渲染效果，适合表达复杂的多媒体内容；Markdown 学习和编辑的难度更小，源文件更简洁直观，但是能实现的功能也更加单一，难以处理复杂的层次结构。因此 Markdown 更加适合比较简单的富文本内容。</p> <div class="note note-primary">            <p><strong>前言</strong>： 不知大家是否和博主有着相同的疑惑，为什么别的博主写出来的博客排版工整、优雅美观，而自己的博客却毫无出彩之处。原先博主更多的关注点在技术博客的内容上，markdown语法仅仅靠csdn上的“语法说明”自己瞎琢磨的，现在放暑假正好有时间，再温习一下基础语法和学习一下进阶语法，来丰富自己的博客排版！这篇是我的学习笔记，博采众长，希望也能帮到大家！</p>          </div><p>  下面分为两个板块进行阐述：<strong>基础语法</strong>和<strong>进阶语法</strong>，板块一可以帮助你简单入门，版块二则是语法的升级！下面我都在代码块中展示markdown的写法，下面是对应的博客展现形式，大家可以根据自己的需求进行选择和学习！</p><h2 id="一、基础语法">一、基础语法</h2><h4 id="1-标题">1.标题</h4><p>输入<code>#</code>+<code>space（空格）</code>就是不同等级的标题（最多只有六个等级）</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><span class="hljs-section">## 二级标题</span><br><span class="hljs-section">### 三级标题</span><br><span class="hljs-section">#### 四级标题</span><br><span class="hljs-section">##### 五级标题</span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></tbody></table></figure><blockquote><h1>一级标题</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6></blockquote><h4 id="2-文本样式">2.文本样式</h4><p><strong>斜体</strong>：<code>*</code>+<code>文本内容</code>+<code>*</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mardown">*这是一个斜体*<br></code></pre></td></tr></tbody></table></figure><blockquote><p><em>这是一个斜体</em></p></blockquote><p><strong>加粗</strong>：<code>**</code>+<code>文本内容</code>+<code>**</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mardown">**这里进行了加粗**<br></code></pre></td></tr></tbody></table></figure><blockquote><p><strong>这里进行了加粗</strong></p></blockquote><p><strong>斜体加粗</strong>：<code>***</code>+<code>文本内容</code>+<code>***</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*这里是斜体加粗*</span>**</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><em><strong>这里是斜体加粗</strong></em></p></blockquote><p><strong>删除线</strong>：<code>~~</code>+<code>文本内容</code>+<code>~~</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~这里是删除线~~<br></code></pre></td></tr></tbody></table></figure><blockquote><p><s>这里是删除线</s></p></blockquote><p><strong>分割线</strong>：在一行中用三个以上的星号建立一个分隔线，行内不能有其他内容，也可以在星号中间插入空格。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> * <span class="hljs-emphasis">*</span><br></code></pre></td></tr></tbody></table></figure><blockquote><hr></blockquote><h4 id="3-列表">3.列表</h4><p><strong>无序列表</strong>：<code>-</code>或<code>*</code>或<code>+</code>+<code>space（空格）</code>+<code>文本内容</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 无序列表1<br><span class="hljs-bullet">-</span> 无序列表2<br><span class="hljs-bullet">-</span> 无序列表3<br></code></pre></td></tr></tbody></table></figure><ul><li>无序列表1</li><li>无序列表2</li><li>无序列表3</li></ul><p><strong>有序列表</strong>：<code>数字序号</code>+<code>.</code>+<code>space（空格）</code>+<code>文本内容</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表1<br><span class="hljs-bullet">2.</span> 有序列表2<br><span class="hljs-bullet">3.</span> 有序列表3<br></code></pre></td></tr></tbody></table></figure><blockquote><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol></blockquote><p><strong>嵌套列表</strong>：<br><code>-</code>+<code>space</code>+<code>第一级无序列表1</code><br><code>space*2</code>+<code>-</code>+<code>第二级无序列表2</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 嵌套列表1<br><span class="hljs-bullet">  -</span> 嵌套列表2<br><span class="hljs-bullet">    -</span> 嵌套列表3<br></code></pre></td></tr></tbody></table></figure><blockquote><ul><li>嵌套列表1<ul><li>嵌套列表2<ul><li>嵌套列表3</li></ul></li></ul></li></ul></blockquote><h4 id="4-板块">4.板块</h4><p><strong>表格</strong>：<br><code>|</code>+ <code>每列的标题</code>+<code>|</code>+<code>每列的标题</code>+<code>|</code><br><code>|</code>+ <code>----| ----</code>+<code>|</code><br><code>|</code>+ <code>每列内容</code>+<code>|</code>+<code>每列内容</code>+<code>|</code><br><code>|</code>+ <code>每列内容</code>+<code>|</code>+<code>每列内容</code>+<code>|</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|语言类型 |输出函数|<br>| --- | ----------- |<br>|c语言|printf|<br>|c++|cout|<br>|python|print|<br></code></pre></td></tr></tbody></table></figure><table><thead><tr><th>语言类型</th><th>输出函数</th></tr></thead><tbody><tr><td>c语言</td><td>printf</td></tr><tr><td>c++</td><td>cout</td></tr><tr><td>python</td><td>print</td></tr></tbody></table><p>可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。</p><blockquote><p>:— 设置内容和标题栏居左对齐。<br>:----: 设置内容和标题栏居中对齐。<br>—: 设置内容和标题栏居右对齐。</p></blockquote><p><strong>代码块</strong>：前后三个```即可，可自定义选择编程语言</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">"这是一个代码块"</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"这是使用的python语言"</span>)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>cout&lt;&lt;<span class="hljs-string">"这是一个c++的代码块！"</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<br></code></pre></td></tr></tbody></table></figure><p><strong>链接</strong>：<code>[</code>+<code>超链接显示名</code>+<code>]</code>+<code>(</code>+<code>超链接地址</code>+<code>)</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">不在了情绪的博客主页：[<span class="hljs-string">不在了情绪</span>](<span class="hljs-link">https://blog.csdn.net/2401_86849688?type=blog</span>)<br></code></pre></td></tr></tbody></table></figure><blockquote><p>不在了情绪的博客主页：<a href="https://blog.csdn.net/2401_86849688?type=blog">不在了情绪</a></p></blockquote><p>我们还可以给这个链接添加title，当鼠标悬停在链接上会出现提示。<br><code>[</code>+<code>超链接显示名</code>+<code>]</code>+<code>(</code>+<code>超链接地址</code>+<code>space</code>+<code>"链接title"</code>+<code>)</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">不在了情绪的博客主页：[<span class="hljs-string">不在了情绪</span>](<span class="hljs-link">https://blog.csdn.net/2401_86849688?type=blog "欢迎来到我的博客！"</span>)<br></code></pre></td></tr></tbody></table></figure><blockquote><p>不在了情绪的博客主页：<a href="https://blog.csdn.net/2401_86849688?type=blog" title="欢迎来到我的博客！">不在了情绪</a></p></blockquote><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml">&lt;https://blog.csdn.net/2401_86849688?type=blog&gt;</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><a href="https://blog.csdn.net/2401_86849688?type=blog">https://blog.csdn.net/2401_86849688?type=blog</a></p></blockquote><p>要显示原本用于格式化 Markdown 文档的字符，需要在字符前面添加反斜杠字符 \</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\<span class="hljs-emphasis">*我想要输出的是两个星号*</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>*我想要输出的是两个星号*</p></blockquote><h2 id="二、进阶用法">二、进阶用法</h2><h4 id="1-字体与背景">1.字体与背景</h4><p><code>&lt;font face="字体"&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">"黑体"</span>&gt;</span></span>这是黑体<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">"微软雅黑"</span>&gt;</span></span>这是微软雅黑<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">"STCAIYUN"</span>&gt;</span></span>这是华文彩云<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><font face="黑体">这是黑体</font><br><font face="微软雅黑">这是微软雅黑</font><br><font face="STCAIYUN">这是华文彩云</font></p></blockquote><p><code>&lt;font size=字体大小&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">4</span>&gt;</span></span>字体大小为4的文字<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">3</span>&gt;</span></span>字体大小为3的文字<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">2</span>&gt;</span></span>字体大小为2的文字<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">1</span>&gt;</span></span>字体大小为1的文字<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><font size="4">字体大小为4的文字</font><br><font size="3">字体大小为3的文字</font><br><font size="2">字体大小为2的文字</font><br><font size="1">字体大小为1的文字</font></p></blockquote><p><code>&lt;font color=“color”&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span></span>红色的文本内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"green"</span>&gt;</span></span>绿色的文本内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"blue"</span>&gt;</span></span>蓝色的文本内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><font color="red">红色的文本内容</font><br><font color="green">绿色的文本内容</font><br><font color="blue">蓝色的文本内容</font></p></blockquote><p><code>&lt;mark&gt;</code>+<code>文本内容</code>+<code>&lt;/mark&gt;</code>或者<code>==</code>+<code>文本内容</code>+<code>==</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span>&gt;</span></span>高亮显示的文本内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span></span><br>==高亮显示的文本内容==<br></code></pre></td></tr></tbody></table></figure><blockquote><p><mark>高亮显示的文本内容</mark><br>==高亮显示的文本内容==</p></blockquote><p><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=“color”&gt;&lt;mark&gt;</code>+<code>文本内容</code>+<code>&lt;/mark&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">"green"</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span>&gt;</span></span>有背景颜色的高亮文本内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">"red"</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span>&gt;</span></span>有背景颜色的高亮文本内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><blockquote><table><tbody><tr><td bgcolor="green"><mark>有背景颜色的高亮文本内容</mark></td></tr></tbody></table><table><tbody><tr><td bgcolor="red"><mark>有背景颜色的高亮文本内容</mark></td></tr></tbody></table></blockquote><p><code>&lt;u&gt;</code>+<code>文本内容</code>+<code>&lt;/u&gt;</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>下划线的文本内容<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><u>下划线的文本内容</u></p></blockquote><p><code>&gt;</code>+<code>文本内容</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;引用的文本内容<br></code></pre></td></tr></tbody></table></figure><blockquote><p>引用的文本内容</p></blockquote><h4 id="2-段落缩进">2.段落缩进</h4><p><strong>首行缩进</strong>：</p><ul><li>全角：<code>&amp;emsp;</code>或<code>&amp;#8195;</code></li><li>半角：<code>&amp;ensp;</code>或<code>&amp;#8194;</code></li><li>半角之半角：<code>&amp;nbsp;</code>或<code>&amp;#160;</code></li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-literal">&amp;emsp;</span><span class="hljs-literal">&amp;emsp;</span>磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！<br></code></pre></td></tr></tbody></table></figure><blockquote><p>  磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！</p></blockquote><h4 id="3-公式">3.公式</h4><p>  在markdown中可以使用<code>$$</code>来作为公式块，在其中进行Latex类型公式的输入！</p><p><code>$</code> + <code>公式</code> + <code>$</code></p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$x^2-y^2=(x+y)(x-y)$<br>$$(x-y)^2=x^2-2xy+y^2$$<br></code></pre></td></tr></tbody></table></figure><blockquote><p>$x<sup>2-y</sup>2=(x+y)(x-y)$</p></blockquote><blockquote><p>$$(x-y)<sup>2=x</sup>2-2xy+y^2$$</p></blockquote><h4 id="4-表情">4.表情</h4><p>我们可以通过键入<code>emoji shortcodes</code>来输出表情包：<br><code>man</code>:</p><table><thead><tr><th>😄 <code>:smile:</code></th><th>😊 <code>:blush:</code></th><th>😍 <code>:heart_eyes:</code></th></tr></thead><tbody><tr><td>😘 <code>:kissing_heart:</code></td><td>😳 <code>:flushed:</code></td><td>😁 <code>:grin:</code></td></tr><tr><td>😉 <code>:wink:</code></td><td>😜 <code>:tongue_wink:</code></td><td>😀 <code>:grinning:</code></td></tr><tr><td>😴 <code>:sleeping:</code></td><td>😟 <code>:worried:</code></td><td>😮 <code>:open_mouth:</code></td></tr><tr><td>😕 <code>:confused:</code></td><td>😑 <code>:expressionless:</code></td><td>😅 <code>:sweat_smile:</code></td></tr><tr><td>😥 <code>:sad_relieved:</code></td><td>😢 <code>:cry:</code></td><td>😭 <code>:sob:</code></td></tr><tr><td>😂 <code>:joy:</code></td><td>😱 <code>:scream:</code></td><td>😠 <code>:angry:</code></td></tr><tr><td>😡 <code>:rage:</code></td><td>😷 <code>:mask:</code></td><td>😎 <code>:sunglasses:</code></td></tr><tr><td>😇 <code>:innocent:</code></td><td>❤️ <code>:heart:</code></td><td>💔 <code>:broken_heart:</code></td></tr><tr><td>✨ <code>:sparkles:</code></td><td>👍 <code>:thumbsup:</code></td><td>👎 <code>:thumbsdown:</code></td></tr><tr><td>👌 <code>:ok_hand:</code></td><td>✊ <code>:fist:</code></td><td>✌️ <code>:v:</code></td></tr><tr><td>👋 <code>:wave:</code></td><td>🙌 <code>:raised_hands:</code></td><td>🙏 <code>:pray:</code></td></tr><tr><td>👏 <code>:clap:</code></td><td>💪 <code>:muscle:</code></td><td>🏃 <code>:running:</code></td></tr><tr><td>👫 <code>:couple:</code></td><td>👪 <code>:family:</code></td><td>💃 <code>:dancer:</code></td></tr><tr><td>🙅 <code>:no_good:</code></td><td>💁 <code>:info_desk:</code></td><td>👶 <code>:baby:</code></td></tr><tr><td>👩 <code>:woman:</code></td><td>👨 <code>:man:</code></td><td>👵 <code>:grandma:</code></td></tr><tr><td>👴 <code>:grandpa:</code></td><td>👮 <code>:police:</code></td><td>😺 <code>:smile_cat:</code></td></tr><tr><td>🙈 <code>:see_no_evil:</code></td><td>💀 <code>:skull:</code></td><td>💋 <code>:kiss:</code></td></tr><tr><td>👀 <code>:eyes:</code></td><td>👄 <code>:mouth:</code></td><td>💬 <code>:speech_bubble:</code></td></tr></tbody></table><p><code>nature</code>:</p><table><thead><tr><th>☀️ <code>:sunny:</code></th><th>☔ <code>:umbrella:</code></th><th>☁️ <code>:cloud:</code></th></tr></thead><tbody><tr><td>❄️ <code>:snowflake:</code></td><td>⛄ <code>:snowman:</code></td><td>⚡ <code>:zap:</code></td></tr><tr><td>🌊 <code>:ocean:</code></td><td>🐱 <code>:cat:</code></td><td>🐶 <code>:dog:</code></td></tr><tr><td>🐭 <code>:mouse:</code></td><td>🐰 <code>:rabbit:</code></td><td>🐯 <code>:tiger:</code></td></tr><tr><td>🐨 <code>:koala:</code></td><td>🐻 <code>:bear:</code></td><td>🐷 <code>:pig:</code></td></tr><tr><td>🐮 <code>:cow:</code></td><td>🐵 <code>:monkey:</code></td><td>🐴 <code>:horse:</code></td></tr><tr><td>🐘 <code>:elephant:</code></td><td>🐼 <code>:panda:</code></td><td>🐍 <code>:snake:</code></td></tr><tr><td>🐦 <code>:bird:</code></td><td>🐤 <code>:chick:</code></td><td>🐧 <code>:penguin:</code></td></tr><tr><td>🐢 <code>:turtle:</code></td><td>🐝 <code>:bee:</code></td><td>🐙 <code>:octopus:</code></td></tr><tr><td>🐠 <code>:fish:</code></td><td>🐳 <code>:whale:</code></td><td>🐬 <code>:dolphin:</code></td></tr><tr><td>🌸 <code>:cherry_blossom:</code></td><td>🌹 <code>:rose:</code></td><td>🌻 <code>:sunflower:</code></td></tr><tr><td>🍁 <code>:maple_leaf:</code></td><td>🍄 <code>:mushroom:</code></td><td>🌵 <code>:cactus:</code></td></tr><tr><td>🌴 <code>:palm_tree:</code></td><td>🌲 <code>:tree:</code></td><td>🌞 <code>:sun_with_face:</code></td></tr><tr><td>🌙 <code>:moon:</code></td><td>🌎 <code>:earth:</code></td><td>🌋 <code>:volcano:</code></td></tr></tbody></table><p><code>objects</code>:</p><table><thead><tr><th>🎍 <code>:bamboo:</code></th><th>💝 <code>:gift_heart:</code></th><th>🎒 <code>:school_satchel:</code></th></tr></thead><tbody><tr><td>🎓 <code>:mortar_board:</code></td><td>🎏 <code>:flags:</code></td><td>🎆 <code>:fireworks:</code></td></tr><tr><td>🎇 <code>:sparkler:</code></td><td>🎃 <code>:jack_o_lantern:</code></td><td>👻 <code>:ghost:</code></td></tr><tr><td>🎅 <code>:santa:</code></td><td>🎄 <code>:christmas_tree:</code></td><td>🎁 <code>:gift:</code></td></tr><tr><td>🔔 <code>:bell:</code></td><td>🎉 <code>:tada:</code></td><td>🎊 <code>:confetti_ball:</code></td></tr><tr><td>🎈 <code>:balloon:</code></td><td>📷 <code>:camera:</code></td><td>🎥 <code>:movie_camera:</code></td></tr><tr><td>💻 <code>:computer:</code></td><td>📺 <code>:tv:</code></td><td>📱 <code>:iphone:</code></td></tr><tr><td>☎️ <code>:phone:</code></td><td>📞 <code>:telephone_receiver:</code></td><td>💡 <code>:bulb:</code></td></tr><tr><td>🔋 <code>:battery:</code></td><td>📧 <code>:email:</code></td><td>✉️ <code>:envelope:</code></td></tr><tr><td>🛀 <code>:bath:</code></td><td>🚿 <code>:shower:</code></td><td>🚽 <code>:toilet:</code></td></tr><tr><td>🔧 <code>:wrench:</code></td><td>🔨 <code>:hammer:</code></td><td>💰 <code>:moneybag:</code></td></tr><tr><td>💵 <code>:dollar:</code></td><td>💳 <code>:credit_card:</code></td><td>✂️ <code>:scissors:</code></td></tr><tr><td>📌 <code>:pushpin:</code></td><td>📎 <code>:paperclip:</code></td><td>✏️ <code>:pencil2:</code></td></tr><tr><td>📕 <code>:closed_book:</code></td><td>📚 <code>:books:</code></td><td>🔖 <code>:bookmark:</code></td></tr><tr><td>⚽ <code>:soccer:</code></td><td>🏀 <code>:basketball:</code></td><td>🎾 <code>:tennis:</code></td></tr><tr><td>🏊 <code>:swimmer:</code></td><td>🎮 <code>:video_game:</code></td><td>🎬 <code>:clapper:</code></td></tr><tr><td>📝 <code>:memo:</code></td><td>🎤 <code>:microphone:</code></td><td>🎧 <code>:headphones:</code></td></tr><tr><td>👞 <code>:shoe:</code></td><td>👠 <code>:high_heel:</code></td><td>💄 <code>:lipstick:</code></td></tr><tr><td>👕 <code>:tshirt:</code></td><td>👖 <code>:jeans:</code></td><td>👙 <code>:bikini:</code></td></tr><tr><td>👑 <code>:crown:</code></td><td>👓 <code>:eyeglasses:</code></td><td>☕ <code>:coffee:</code></td></tr><tr><td>🍵 <code>:tea:</code></td><td>🍺 <code>:beer:</code></td><td>🍕 <code>:pizza:</code></td></tr><tr><td>🍔 <code>:hamburger:</code></td><td>🍟 <code>:fries:</code></td><td>🍣 <code>:sushi:</code></td></tr><tr><td>🍚 <code>:rice:</code></td><td>🍰 <code>:cake:</code></td><td>🍫 <code>:chocolate_bar:</code></td></tr><tr><td>🍎 <code>:apple:</code></td><td>🍌 <code>:banana:</code></td><td>🍅 <code>:tomato:</code></td></tr></tbody></table><p><code>place</code>:</p><table><thead><tr><th>🏠 <code>:house:</code></th><th>🏡 <code>:house_with_garden:</code></th><th>🏫 <code>:school:</code></th></tr></thead><tbody><tr><td>🏢 <code>:office:</code></td><td>🏣 <code>:post_office:</code></td><td>🏥 <code>:hospital:</code></td></tr><tr><td>🏦 <code>:bank:</code></td><td>🏪 <code>:convenience_store:</code></td><td>🏨 <code>:hotel:</code></td></tr><tr><td>💒 <code>:wedding:</code></td><td>⛪ <code>:church:</code></td><td>🌇 <code>:city_sunrise:</code></td></tr><tr><td>🏯 <code>:japanese_castle:</code></td><td>🏰 <code>:european_castle:</code></td><td>⛺ <code>:tent:</code></td></tr><tr><td>🏭 <code>:factory:</code></td><td>🗼 <code>:tokyo_tower:</code></td><td>🗻 <code>:mount_fuji:</code></td></tr><tr><td>🌄 <code>:sunrise_over_mountains:</code></td><td>🌅 <code>:sunrise:</code></td><td>🌈 <code>:rainbow:</code></td></tr><tr><td>🎡 <code>:ferris_wheel:</code></td><td>⛲ <code>:fountain:</code></td><td>🎢 <code>:roller_coaster:</code></td></tr><tr><td>🚢 <code>:ship:</code></td><td>🚤 <code>:speedboat:</code></td><td>⛵ <code>:sailboat:</code></td></tr><tr><td>🚀 <code>:rocket:</code></td><td>✈️ <code>:airplane:</code></td><td>🚁 <code>:helicopter:</code></td></tr><tr><td>🚂 <code>:train:</code></td><td>🚊 <code>:tram:</code></td><td>🚲 <code>:bike:</code></td></tr><tr><td>🚗 <code>:car:</code></td><td>🚕 <code>:taxi:</code></td><td>🚌 <code>:bus:</code></td></tr><tr><td>🚓 <code>:police_car:</code></td><td>🚑 <code>:ambulance:</code></td><td>🚚 <code>:truck:</code></td></tr><tr><td>🚦 <code>:traffic_light:</code></td><td>⚠️ <code>:warning:</code></td><td>🚧 <code>:construction:</code></td></tr><tr><td>🏧 <code>:atm:</code></td><td>🎫 <code>:ticket:</code></td><td>♨️ <code>:hotsprings:</code></td></tr></tbody></table><p><code>number</code>&amp;&amp; <code>directions</code>:</p><table><thead><tr><th>1️⃣ <code>:one:</code></th><th>2️⃣ <code>:two:</code></th><th>3️⃣ <code>:three:</code></th></tr></thead><tbody><tr><td>4️⃣ <code>:four:</code></td><td>5️⃣ <code>:five:</code></td><td>6️⃣ <code>:six:</code></td></tr><tr><td>7️⃣ <code>:seven:</code></td><td>8️⃣ <code>:eight:</code></td><td>9️⃣ <code>:nine:</code></td></tr><tr><td>🔟 <code>:keycap_ten:</code></td><td>0️⃣ <code>:zero:</code></td><td>#️⃣ <code>:hash:</code></td></tr><tr><td>◀️ <code>:arrow_backward:</code></td><td>⬇️ <code>:arrow_down:</code></td><td>▶️ <code>:arrow_forward:</code></td></tr><tr><td>⬅️ <code>:arrow_left:</code></td><td>➡️ <code>:arrow_right:</code></td><td>⬆️ <code>:arrow_up:</code></td></tr><tr><td>🔄 <code>:arrows_counterclockwise:</code></td><td>ℹ️ <code>:information_source:</code></td><td>🆗 <code>:ok:</code></td></tr><tr><td>🆕 <code>:new:</code></td><td>🆙 <code>:up:</code></td><td>🆒 <code>:cool:</code></td></tr><tr><td>🚻 <code>:restroom:</code></td><td>🚹 <code>:mens:</code></td><td>🚺 <code>:womens:</code></td></tr><tr><td>♿ <code>:wheelchair:</code></td><td>🚇 <code>:metro:</code></td><td>🚫 <code>:no_entry_sign:</code></td></tr><tr><td>⛔ <code>:no_entry:</code></td><td>♻️ <code>:recycle:</code></td><td>🕐 <code>:clock1:</code></td></tr><tr><td>❌ <code>:x:</code></td><td>❗ <code>:exclamation:</code></td><td>⭕ <code>:o:</code></td></tr><tr><td>➕ <code>:plus:</code></td><td>➖ <code>:minus:</code></td><td>✔️ <code>:check_mark:</code></td></tr><tr><td>🔘 <code>:radio_button:</code></td><td>🔗 <code>:link:</code></td><td>✅ <code>:white_check_mark:</code></td></tr><tr><td>⚫ <code>:black_circle:</code></td><td>⚪ <code>:white_circle:</code></td><td>🔴 <code>:red_circle:</code></td></tr><tr><td>🔵 <code>:blue_circle:</code></td><td>©️ <code>:copyright:</code></td><td>®️ <code>:registered:</code></td></tr><tr><td>™️ <code>:tm:</code></td><td>🔶 <code>:orange_diamond:</code></td><td>🔷 <code>:blue_diamond:</code></td></tr></tbody></table><h4 id="5-提示">5.提示</h4><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">{%note 参数%} 文字内容 {%endnote%}<br></code></pre></td></tr></tbody></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>default</code></td><td>默认样式（灰色）</td></tr><tr><td><code>primary</code></td><td>主要样式（蓝色）</td></tr><tr><td><code>info</code></td><td>信息提示（浅蓝色）</td></tr><tr><td><code>success</code></td><td>成功提示（绿色）</td></tr><tr><td><code>warning</code></td><td>警告提示（黄色）</td></tr><tr><td><code>danger</code></td><td>危险/错误（红色）</td></tr></tbody></table><ul><li><code>default</code></li></ul><div class="note note-info">            <p>默认！</p>          </div><ul><li><code>primary</code></li></ul><div class="note note-primary">            <p>主要！</p>          </div><ul><li><code>info</code></li></ul><div class="note note-info">            <p>提示！</p>          </div><ul><li><code>success</code></li></ul><div class="note note-success">            <p>成功！</p>          </div><ul><li><code>warning</code></li></ul><div class="note note-warning">            <p>警告！</p>          </div><ul><li><code>danger</code></li></ul><div class="note note-danger">            <p>危险！</p>          </div><p>恭喜！ 看到这里你已经掌握了 Markdown 的核心语法和进阶技巧！</p><p>✨ 小建议：</p><p>精致排版 + 优质内容 = 王炸组合 💥 清晰的结构和美观的格式会让你的博客更专业、更吸睛！</p><p>立刻动手写一篇吧！ 从今天开始，用 Markdown 打造你的技术分享博客，下一个顶尖技术博主就是你！ 🚀</p><p>参考文献：<br><a href="https://blog.csdn.net/weixin_69553582/article/details/142665344">Markdown 语法详解大全(超级版)（一）——标题、字体文本式样、颜色、列表、版块区块、缩进、列表项</a><br><a href="https://blog.csdn.net/weixin_69553582/article/details/142711165">Markdown 语法详解大全(超级版)（二）——图片、表格、段落、转义字符、内嵌、注释、缩进、公式</a><br><a href="https://blog.csdn.net/weixin_69553582/article/details/142719257">Markdown 语法详解大全(超级版)（三）——甘特图语法详解</a><br><a href="https://blog.csdn.net/weixin_69553582/article/details/140277283">Markdown 语法详解大全(超级版)（四）——Markdown 使用 Emoji 表情 （附：表情符号简码列表）</a></p>]]></content>
    
    
    <categories>
      
      <category>Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
      <tag>blogger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World！</title>
    <link href="/2020/05/01/other/hello-world/"/>
    <url>/2020/05/01/other/hello-world/</url>
    
    <content type="html"><![CDATA[<p><strong>这是我的第一篇博客内容，简单记录了博客的撰写和每次更新的流程！</strong></p><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post-创建新文章">Create a new post(创建新文章)</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server-启动本地服务器">Run server(启动本地服务器)</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></tbody></table></figure><p>会出现</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop<br></code></pre></td></tr></tbody></table></figure><p>这样就可以在本地服务器上进行测试了！</p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Wipe-cache-partition-清理缓存">Wipe cache partition(清理缓存)</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></tbody></table></figure><h3 id="Generate-static-files-生成静态文件">Generate static files(生成静态文件)</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites-部署到github远程站点">Deploy to remote sites(部署到github远程站点)</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Integrate-将上述步骤简化为一个命令行操作">Integrate (将上述步骤简化为一个命令行操作)</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></tbody></table></figure><p>封面来源：<a href="https://www.youtube.com/watch?v=u7JMhVI7taQ&amp;list=RDu7JMhVI7taQ&amp;start_radio=1">Alan Walker &amp; Torine - Hello World (Official Music Video)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
